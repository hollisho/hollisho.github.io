[{"content":"原理 Shopify App 本质上是一个 独立的 Web 应用，但可以嵌入到 Shopify 后台（Admin）或店铺前端（Online Store）。 你可以选择用 Remix + Node.js，或者 PHP（Laravel、Slim 等）。\n🔹 传统 PHP 实现 Shopify App 1️⃣ Shopify 后台 → 访问你的 PHP 服务器（Admin API / Storefront API） 2️⃣ PHP 处理请求，查询数据库 3️⃣ PHP 渲染 HTML，返回给 Shopify 手动创建应用 配置应用信息 让Shopify Cli识别现有项目 先创建 Shopify App 配置 在 PHP 项目根目录手动创建 shopify.app.toml 文件：\n1 touch shopify.app.toml 然后在 shopify.app.toml 里添加：\n1 2 name = \u0026#34;My Laravel Shopify App\u0026#34; scopes = \u0026#34;read_products, write_products\u0026#34; 初始化 package.json 文件 在根目录生成一个空壳 package.json：\n1 2 3 bash复制编辑cd ~/workspace/shopify-php echo \u0026#39;{}\u0026#39; \u0026gt; package.json 或者运行：\n1 npm init -y 这会生成：\n1 2 3 4 5 6 { \u0026#34;name\u0026#34;: \u0026#34;shopify-php\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34; } 📌 这样 Shopify CLI 就能识别你的 PHP 项目是一个 Shopify App 了！\n然后，再运行：\n1 shopify app dev 选择测试商店 如何添加 Theme App Extension 什么是 Theme App Extension？ Theme App Extension 允许你的 Shopify App 自动在商店的 Liquid 主题里添加代码，比如 插入翻译 JS、按钮、HTML 片段 等，而无需商家手动修改代码。\nPHP Shopify App 添加 Theme App Extension 的步骤 🔹在 Shopify CLI 里创建 Theme App Extension 你的 PHP App 是后台，Theme App Extension 需要单独用 Shopify CLI 创建。\n1️⃣ 进入你的 PHP App 目录\n1 cd /your-laravel-shopify-app 2️⃣ 使用 Shopify CLI 创建 Theme App Extension\n1 shopify app generate extension 📌 这里选择 Theme app extension 主题扩展。然后根据提示输入扩展的名称\n3️⃣ 进入新创建的扩展目录\n1 cd extensions/theme-translation 4️⃣ 运行开发模式（用于本地预览）\n1 shopify app dev 📌 这样 Shopify 主题就可以加载你的 Theme App Extension 进行测试。\n🔹修改 Theme App Extension 的 Liquid 代码 创建扩展后，你会看到 blocks/ 目录，里面有 .liquid 文件。\n你可以添加 一个翻译切换组件，让用户点击切换语言：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 liquid复制编辑\u0026lt;div class=\u0026#34;translation-widget\u0026#34;\u0026gt; \u0026lt;button onclick=\u0026#34;switchLanguage(\u0026#39;en\u0026#39;)\u0026#34;\u0026gt;English\u0026lt;/button\u0026gt; \u0026lt;button onclick=\u0026#34;switchLanguage(\u0026#39;fr\u0026#39;)\u0026#34;\u0026gt;Français\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; function switchLanguage(lang) { fetch(\u0026#39;/apps/translation/switch\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ language: lang }) }).then(() =\u0026gt; location.reload()); } \u0026lt;/script\u0026gt; 📌 这段代码会被插入到店铺主题里，让用户可以点击按钮切换语言。\n🔹让 PHP 处理语言切换 在 Laravel 后端，添加一个 路由来处理翻译切换：\n📌 routes/web.php\n1 2 3 4 5 6 7 8 use Illuminate\\Http\\Request; use Illuminate\\Support\\Facades\\Session; Route::post(\u0026#39;/apps/translation/switch\u0026#39;, function (Request $request) { $language = $request-\u0026gt;input(\u0026#39;language\u0026#39;); Session::put(\u0026#39;shopify_locale\u0026#39;, $language); return response()-\u0026gt;json([\u0026#39;success\u0026#39; =\u0026gt; true]); }); 📌 这会在 Session 里存储语言信息，然后你的 Laravel API 就可以返回不同语言的数据。\n🔹在 PHP 里修改 API 响应 如果你的 PHP App 需要返回不同语言的数据，你可以在 API 里动态返回翻译内容：\n📌 routes/api.php\n1 2 3 4 5 6 7 8 9 10 Route::get(\u0026#39;/translations\u0026#39;, function () { $language = Session::get(\u0026#39;shopify_locale\u0026#39;, \u0026#39;en\u0026#39;); $translations = [ \u0026#39;en\u0026#39; =\u0026gt; [\u0026#39;welcome\u0026#39; =\u0026gt; \u0026#39;Welcome to our store!\u0026#39;], \u0026#39;fr\u0026#39; =\u0026gt; [\u0026#39;welcome\u0026#39; =\u0026gt; \u0026#39;Bienvenue dans notre magasin!\u0026#39;] ]; return response()-\u0026gt;json([\u0026#39;message\u0026#39; =\u0026gt; $translations[$language][\u0026#39;welcome\u0026#39;]]); }); 📌 这样，你的前端可以调用 /api/translations 来获取翻译后的内容。\n🔹部署 Theme App Extension 1️⃣ 构建扩展\n1 shopify extension build 2️⃣ 提交扩展\n1 shopify extension push 3️⃣ 在 Shopify Partner Dashboard 里发布\n进入 Shopify Partner Dashboard 进入你的 App 在 App Extensions 里找到 Theme App Extension 点击 发布 📌 这样，商家安装你的 App 后，扩展就会自动出现在他们的主题里！\n","date":"2025-04-08T15:20:25+08:00","permalink":"https://hollisho.github.io/p/%E4%BC%A0%E7%BB%9F-php-%E5%AE%9E%E7%8E%B0-shopify-app/","title":"传统 PHP 实现 Shopify App"},{"content":"Redis缓存一致性同步方案以及适用场景 常见同步方案 Cache-Aside（旁路缓存） 原理 读操作：先查询Redis，未命中则读取MySQL，并将结果回写到Redis 写操作：直接写入MySQL，然后删除Redis中对应的缓存（或更新） 详细实现方案 架构组件：\n应用层：负责协调缓存和数据库操作 缓存层：Redis集群 存储层：MySQL数据库 数据流向：\n读取流程：应用层 → Redis → (缓存未命中) → MySQL → 应用层 → Redis 写入流程：应用层 → MySQL → 应用层 → Redis(删除缓存) 一致性保障：\n采用「先更新数据库，后删除缓存」的策略 使用延迟双删策略：更新DB后立即删除缓存，并在一定延迟后再次删除缓存，避免并发问题 缓存删除操作失败时，通过重试队列进行补偿 异常处理：\n缓存删除失败：记录日志，加入重试队列 数据库操作失败：事务回滚，不执行缓存操作 缓存穿透防护：布隆过滤器 + 空值缓存 缓存击穿防护：热点数据互斥锁 优点 实现简单、灵活，适用于大部分场景 读写分离，互不影响 可根据业务需求灵活调整缓存策略 缺点 存在短暂不一致窗口（如删除缓存失败） 有缓存穿透/击穿风险 在高并发场景下可能出现「写-读」并发导致的不一致 适用场景 读多写少的业务（如用户信息、商品详情） 允许短暂不一致的业务场景 对缓存命中率要求较高的系统 Read/Write Through（穿透读写） 原理 读操作：请求先到缓存，未命中则由缓存层从MySQL加载并返回 写操作：应用直接写缓存，缓存层同步写MySQL 详细实现方案 架构组件：\n应用层：只与缓存层交互 缓存代理层：封装缓存与数据库的交互逻辑 缓存层：Redis集群 存储层：MySQL数据库 数据流向：\n读取流程：应用层 → 缓存代理层 → Redis → (缓存未命中) → 缓存代理层 → MySQL → 缓存代理层 → Redis → 应用层 写入流程：应用层 → 缓存代理层 → Redis → 缓存代理层 → MySQL 一致性保障：\n缓存代理层负责协调缓存和数据库的一致性 写操作可采用事务机制确保缓存和数据库的原子性更新 可实现为分布式缓存框架，如Spring Cache、Redisson等 异常处理：\n数据库写入失败：回滚缓存更新，返回错误 缓存更新失败：可选择回滚数据库或重试缓存更新 读取异常：降级为直接读取数据库 优点 对应用层透明，一致性较好 简化应用层逻辑，集中处理缓存逻辑 减少应用层与数据库的直接交互 缺点 需要实现或引入专门的缓存代理层 增加了系统复杂度 写操作性能可能受到影响（同步写入数据库） 适用场景 需要高一致性且缓存层支持自动回写的业务（如金融账户余额） 希望简化应用层缓存逻辑的系统 读写比例相对均衡的业务场景 Write Behind（异步回写） 原理 应用直接写Redis，Redis异步批量写入MySQL 详细实现方案 架构组件：\n应用层：只与缓存层交互 缓存层：Redis集群 异步写入服务：负责将缓存变更异步写入数据库 存储层：MySQL数据库 写入队列：存储待写入数据库的操作 数据流向：\n读取流程：应用层 → Redis 写入流程：应用层 → Redis → 写入队列 → 异步写入服务 → MySQL 一致性保障：\n采用写入队列持久化缓存变更操作 批量写入策略：按时间窗口或数据量阈值触发批量写入 写入确认机制：成功写入数据库后标记队列中的操作为已完成 异常处理：\n队列容错：使用持久化队列（如Redis Stream、Kafka）确保消息不丢失 写入失败：重试机制 + 告警通知 缓存宕机：从队列恢复未完成的写入操作 数据库宕机：队列堆积，设置最大重试次数和告警阈值 优点 高吞吐量，减少数据库写入压力 支持批量写入优化 应用层写入延迟低 缺点 数据丢失风险（缓存宕机时） 一致性较弱（最终一致性） 实现复杂度高 适用场景 写密集型且允许最终一致性的场景（如日志记录、计数器） 高并发写入场景（如社交媒体点赞、评论） 对写入性能要求高的系统 双写（Double Write） 原理 应用同时写Redis和MySQL，依赖事务或重试机制保证原子性 详细实现方案 架构组件：\n应用层：同时负责写入缓存和数据库 缓存层：Redis集群 存储层：MySQL数据库 分布式锁服务：确保并发安全 数据流向：\n读取流程：应用层 → Redis → (缓存未命中) → MySQL → 应用层 → Redis 写入流程：应用层 → [分布式锁] → MySQL + Redis（并行或串行） 一致性保障：\n使用分布式锁确保同一数据的写入串行化 采用本地事务 + 补偿机制：先写数据库，再写缓存，缓存写入失败则加入重试队列 可选择TCC（Try-Confirm-Cancel）模式实现跨资源的事务 异常处理：\n数据库写入成功但缓存失败：记录失败操作，异步重试或定时补偿 缓存写入成功但数据库失败：事务回滚，删除缓存 并发冲突：通过分布式锁避免，或使用乐观锁进行冲突检测 优点 实时性高，读取时数据一致性好 无需额外的异步组件 架构相对简单 缺点 需要处理写失败的不一致（如Redis成功但MySQL失败） 增加了写操作的延迟 分布式事务复杂度高 适用场景 对实时性要求高且写操作较少的业务（如配置信息） 对数据一致性要求较高的场景 读写比例相对均衡且并发不是特别高的系统 基于Binlog的异步同步 原理 通过监听MySQL的Binlog（如Canal、Debezium），解析变更后同步到Redis 详细实现方案 架构组件：\n应用层：只负责写入数据库，读取时优先读缓存 Binlog采集器：如Canal、Debezium等 变更处理服务：解析Binlog并转换为缓存操作 缓存层：Redis集群 存储层：MySQL数据库 数据流向：\n读取流程：应用层 → Redis → (缓存未命中) → MySQL → 应用层 写入流程：应用层 → MySQL → Binlog → Binlog采集器 → 变更处理服务 → Redis 一致性保障：\n利用Binlog的有序性和事务特性确保数据变更的顺序一致 变更处理服务保存处理位点，支持从断点续传 定期全量同步校验，修复不一致数据 异常处理：\nBinlog解析失败：记录错误位点，人工介入 网络中断：基于位点机制，恢复后从断点继续处理 Redis更新失败：重试机制，持久化失败记录 数据不一致检测：定期对比校验机制 优点 解耦应用层，对应用透明 保证最终一致性 可靠性高，基于数据库事务日志 缺点 架构复杂，需要额外组件 延迟较高（通常秒级） 需要处理Binlog格式变更等问题 适用场景 强一致性要求的业务（如订单状态、库存扣减） 希望减轻应用层负担的系统 已有成熟的Binlog采集基础设施的团队 消息队列异步处理 原理 写MySQL后发送消息到队列（如Kafka、RabbitMQ），消费者更新Redis 详细实现方案 架构组件：\n应用层：写入数据库并发送消息到队列 消息队列：如Kafka、RabbitMQ 缓存更新服务：消费消息并更新缓存 缓存层：Redis集群 存储层：MySQL数据库 数据流向：\n读取流程：应用层 → Redis → (缓存未命中) → MySQL → 应用层 写入流程：应用层 → MySQL → 应用层 → 消息队列 → 缓存更新服务 → Redis 一致性保障：\n本地事务确保数据库更新和消息发送的原子性（如本地消息表模式） 消息队列的可靠投递机制（如持久化、确认机制） 消费者的幂等处理，避免重复消费导致的问题 异常处理：\n消息发送失败：本地重试或消息表补偿 消息消费失败：重试策略 + 死信队列 缓存更新失败：记录失败操作，定时重试 消息堆积：监控告警，动态扩容消费者 优点 系统解耦，便于扩展 支持削峰填谷，提高系统稳定性 可以灵活处理复杂的缓存更新逻辑 缺点 需要容忍一定的延迟 可能因消息堆积导致不一致时间延长 需要处理消息重复消费问题 适用场景 异步处理高并发写入（如社交点赞、评论数更新） 需要解耦的分布式系统 允许最终一致性的业务场景 定时任务同步 原理 定时从MySQL拉取增量数据，批量更新Redis 详细实现方案 架构组件：\n应用层：只负责写入数据库，读取时优先读缓存 定时同步服务：定期从数据库读取数据并更新缓存 缓存层：Redis集群 存储层：MySQL数据库 数据流向：\n读取流程：应用层 → Redis → (缓存未命中) → MySQL → 应用层 写入流程：应用层 → MySQL 同步流程：定时同步服务 → MySQL → 定时同步服务 → Redis 一致性保障：\n基于时间戳或版本号识别增量数据 批量同步策略：全量同步 + 增量更新 同步任务的分片和并行处理，提高效率 异常处理：\n同步任务失败：记录失败点，下次继续 数据库负载过高：动态调整同步频率和批次大小 缓存更新冲突：基于版本号或时间戳解决 优点 实现简单，易于维护 对应用层完全透明 可控的同步频率，避免对数据库造成冲击 缺点 实时性差，存在较长的不一致窗口 可能重复更新相同数据 全量同步资源消耗大 适用场景 对实时性不敏感的数据（如每日排行榜） 数据变更频率低的业务 系统负载敏感，需要控制同步频率的场景 场景与方案匹配 场景类型 推荐方案 理由 高并发读，弱一致性 Cache-Aside + 过期时间 简单有效，缓存穿透可通过布隆过滤器或空值缓存优化。延迟双删策略可减少不一致窗口。 高并发写，允许最终一致性 Write Behind 或消息队列 降低数据库压力，通过异步批量写入保证吞吐量。写入队列可确保数据不丢失。 强一致性要求（如金融交易） Binlog 同步 + 事务机制 通过Binlog保证数据变更可靠性，结合事务避免中间状态。支持断点续传和全量校验。 读多写少，需高实时性 双写 + 分布式锁（或事务） 确保双写原子性，分布式锁避免并发问题。补偿机制处理异常情况。 数据更新低频，容忍延迟 定时任务同步 实现成本低，适合不频繁变更的数据。可控的同步频率减轻系统负担。 架构解耦，需高扩展性 消息队列 + Binlog 同步 结合消息队列的异步处理与Binlog的可靠性，适合分布式系统。支持多种消费者模式。 关键注意事项 一致性权衡 强一致性：通常牺牲性能和可用性，适用于金融交易等核心业务 最终一致性：提高系统吞吐量，但需业务容忍短暂的数据不一致 弱一致性：性能最佳，适用于对一致性要求不高的场景（如统计数据） 异常处理 双写失败：\n设计补偿机制（如重试队列、定时任务检查） 实现回滚机制，确保数据库和缓存的一致性 关键操作日志记录和告警通知 Binlog同步：\n处理网络中断后的数据追赶（位点管理） 处理Binlog格式变更和表结构变更 实现数据校验和修复机制 缓存策略 过期时间设置：\n根据数据更新频率和重要性设置差异化过期时间 避免冷数据长期占用内存 考虑使用LRU/LFU等淘汰策略 缓存防护：\n使用分布式锁防止缓存击穿（热点key失效） 布隆过滤器防止缓存穿透（查询不存在的数据） 限流熔断机制防止缓存雪崩（大量key同时失效） 性能监控 监控Redis和MySQL的延迟、命中率、连接数等指标 设置关键指标的告警阈值 根据监控数据动态调整缓存策略（如扩容、调整过期时间） 构建缓存预热机制，避免冷启动问题 典型案例 电商库存系统 方案：Binlog同步（强一致性）+ 缓存预扣减 实现细节： Redis存储商品当前库存，支持原子减操作 库存扣减先在Redis执行，成功后异步通知MySQL 通过Binlog同步确保MySQL和Redis最终一致 定期全量校验修复不一致数据 异常处理： 超卖防护：Redis分布式锁 + 库存校验 库存不足：快速失败，提升用户体验 数据不一致：告警 + 自动修复 社交媒体动态系统 方案：消息队列异步更新计数 实现细节： Redis存储点赞、评论等计数器 用户操作写入MySQL，同时发送消息到队列 消费者批量更新Redis计数器 定时任务校准计数，修正偏差 优化点： 消息批量处理提高吞吐量 计数器分片减少热点问题 容忍短暂不一致，提升用户体验 用户会话管理 方案：Cache-Aside + 短过期时间 实现细节： Redis存储用户会话信息，设置合理过期时间 读取优先从Redis获取，未命中则从MySQL加载 更新会话信息时先更新MySQL，再删除Redis缓存 采用延迟双删策略减少不一致窗口 安全考虑： 敏感信息加密存储 会话标识定期轮换 异常登录检测和防护 总结 选择缓存一致性方案时，需综合考虑以下因素：\n业务需求：一致性要求、实时性要求、读写比例 团队技术栈：现有基础设施、技术能力、维护成本 运维成本：监控、告警、故障恢复能力 在实际应用中，通常会混合使用多种策略：\n核心交易数据：使用Binlog同步或双写 + 分布式锁 高频读取数据：使用Cache-Aside + 合理过期时间 高并发写入数据：使用Write Behind或消息队列 统计类数据：使用定时任务同步或异步更新 最佳实践是根据数据特性和业务场景，为不同类型的数据选择最合适的缓存一致性策略，在保证系统可靠性的同时，最大化性能和用户体验。\n","date":"2025-03-28T14:55:52+08:00","permalink":"https://hollisho.github.io/p/redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%E4%BB%A5%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/","title":"Redis缓存一致性同步方案以及适用场景"},{"content":"Shopify App开发知识整理 修订记录 日期 版本 说明 作者 2024-07-08 v1.0.0 Hollis 前期准备 相关网址 Shopify官网（https://www.shopify.com/）\nShopify开发文档（https://shopify.dev/）\nShopify合作伙伴（https://www.shopify.com/partners）\n相关概念 Partner （合作伙伴）\nShopify 开发者账号，用于开发App、Theme、Extension等 App （应用）\n扩展店铺的功能，可以发布到应用市场 Theme (主题)\n设计店铺的样式，可以发布到主题市场 Custom storefront （自定义店铺）\n商店 在合作伙伴后台添加开发商城，跟着设置指南完成商店设置\nShopify Cli 本地开发环境 安装 Node.js 20.15+ 安装Node.js包管理器 npm、Yarn 或 pnpm 安装 Ruby 2.7+ 安装 Git 2.44+ 安装Shopify Cli 1 npm install -g @shopify/cli@latest 具体安装依赖参考官方文档：https://shopify.dev/docs/api/shopify-cli\n应用 商店后台应用 您可以构建一个应用程序来为 Shopify 商店添加功能并扩展商家体验，或者为客户创造独特的购买体验。您还可以将 Shopify 商店数据提取到您的应用程序、平台或集成中。\n为了根据他们的特定需求定制体验，商家使用 Shopify 应用来帮助建立他们的业务，与外部服务集成，并向他们的 Shopify 后台添加功能。 官方文档：https://shopify.dev/docs/apps/build/scaffold-app\n创建新应用 1 shopify app init 本地运行应用 1 2 cd ho-app #进入应用目录 npm run dev #运行应用 通过控制台输出的Preview URL，查看App 商店前台应用 商店前台应用也叫：主题应用扩展Extension（应用程序块、应用程序嵌入块）\n主题应用程序扩展为您的应用程序提供了两种扩展在线商店主题的集成类型：应用程序块和应用程序嵌入块。您提交到 Shopify 应用商店的每个新应用都需要使用主题应用扩展来与在线商店主题集成。\n主题应用程序扩展允许商家轻松地将动态元素添加到他们的主题中，而无需与 Liquid 模板或代码进行交互。例如，动态元素可以包括产品评论、价格、评级或产品的交互式 3D 模型。\n优点\n主题应用程序扩展会自动在主题编辑器中公开您的应用程序。您可以利用编辑器的可视化编辑功能，而无需在您的应用程序中复制它们。 您可以同时将您的应用程序部署到使用它的所有在线商店。您还可以访问Shopify CDN 上的应用程序版本控制和资产托管的生命周期管理。 一组集成逻辑和指令适用于所有主题。 商家不需要手动编辑他们的主题代码。 该部分功能还未深入研究，构建步骤略。详情参考官方文档：https://shopify.dev/docs/apps/build/online-store\n主题 创建主题 1 shopify theme init 运行主题 1 2 3 cd ho-theme # 进入主题目录 # 运行shopify theme dev --store {store}（store为开发商店的名称）。 shopify theme dev --store quickstart-c1709595 运行成功之后，通过http://127.0.0.1:9292/访问主题\nAdmin API App需要获取shopify的信息如产品、订单、客户信息等，需要通过Admin API获取。\n还有App的授权和鉴权都是通过Admin API方式。\nAdmin API分为GraphQL Admin API、REST Admin API。\nGraphQL Admin API官方文档：https://shopify.dev/docs/api/admin-graphql\nREST Admin API官方文档：https://shopify.dev/docs/api/admin-rest\n特别说明：本报告中案例采用REST Admin API方式\nApp授权和鉴权 Shopify中有两种Token，分别是Session Token会话令牌和Access Token访问令牌。\n会话令牌用于身份验证，不能替代授权。详细了解身份验证和授权之间的区别。\n与 API 访问令牌不同，会话令牌不能用于向 Shopify API 发出经过身份验证的请求。API 访问令牌可用于从应用的后端向 Shopify 发送请求，以便从用户的商店中获取特定数据。\n例如，要向GraphQL Admin API发出经过身份验证的请求，您的应用必须存储其在 OAuth 流程中收到的访问令牌。相比之下，会话令牌由您的应用的后端用来验证来自您的应用前端的嵌入式请求。\n下图显示了使用会话令牌和 API 访问令牌的身份验证过程：\n官方文档：https://shopify.dev/docs/apps/build/authentication-authorization/session-tokens\n总结：Session Token是App 前端和后端交互的凭证；Access Token是App 后端和Shopify交互的凭证。\nOAuth授权 流程图 Access Token Shopify 的 Access Token 分为两种类型：在线 和 离线\nOnline Access Token 使用在线访问模式创建的访问令牌是临时的，并且一定会在一段时间后过期。访问令牌过期后，Shopify 会返回401 Unauthorized响应代码。\n用户可以随时撤销对您应用的访问权限，而不会影响其他用户访问令牌的有效性。当用户退出 Shopify 管理平台时，在同一网络会话期间创建的所有在线模式访问令牌都将被撤销。\nOffline Access Token 使用离线访问模式创建的访问令牌是永久性的。仅当从商店卸载应用程序时，它们才会被撤销。\n多次授权应用进行离线访问时，每次都会返回相同的访问令牌。获得商店的离线访问权限后，只有在卸载应用或需要其他访问范围时才需要重新授权应用。\n","date":"2025-03-26T10:10:47+08:00","permalink":"https://hollisho.github.io/p/shopify-app%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/","title":"Shopify App开发知识整理"},{"content":"微信支付签名（基于对称加密） 优点 性能高 对称加密算法（如MD5、HMAC-SHA256）计算速度快，适合高并发场景。 微信支付每天处理海量交易，性能是关键考量。 实现简单 只需要一个共享的API密钥（商户和微信支付平台都知道），实现和部署较为简单。 不需要管理复杂的公钥和私钥对。 适合短周期请求 微信支付的请求生命周期短，通常只需在请求和响应的短时间内保证数据完整性，对称加密足够满足需求。 兼容性强 对称加密算法广泛支持，各种编程语言和平台都能轻松实现。 缺点 密钥管理风险 API密钥需要共享，存在泄露风险。如果密钥泄露，攻击者可以伪造请求。 需要定期更换密钥以降低风险。 不支持不可否认性 对称加密无法证明请求的唯一来源，因为双方共享同一个密钥。 如果发生纠纷，无法通过签名证明请求是由某一方发起的。 安全性较低 相比非对称加密，对称加密的安全性较弱，尤其是在密钥泄露的情况下。 电子签名（基于非对称加密） 优点 安全性高 非对称加密使用公钥和私钥对，私钥无需共享，安全性更高。 即使公钥泄露，也无法伪造签名。 不可否认性 签名是用私钥生成的，只有持有私钥的一方才能生成签名，因此可以证明请求的唯一来源。 在法律和审计场景中非常重要。 数据完整性 电子签名不仅可以验证数据完整性，还可以验证数据的真实性。 缺点 性能低 非对称加密算法（如RSA、ECC）计算复杂度高，速度较慢。 在高并发场景下（如微信支付），性能可能成为瓶颈。 实现复杂 需要管理公钥和私钥对，密钥分发和管理复杂度高。 需要额外的基础设施（如证书颁发机构CA）来支持公钥的分发和验证。 不适合短周期请求 非对称加密更适合长期有效的数据签名（如合同、证书），而微信支付的请求生命周期短，使用非对称加密显得过于复杂。 微信支付为什么选择对称加密签名？ 业务场景需求 微信支付的核心需求是数据完整性和身份认证，而不是不可否认性。 支付请求的生命周期短，通常只需在短时间内保证数据安全。 性能优先 微信支付每天处理数十亿笔交易，性能是关键。对称加密的计算速度远快于非对称加密。 实现简单 对称加密的实现和部署更简单，适合快速迭代和扩展。 风险可控 虽然对称加密的密钥管理存在风险，但微信支付通过其他安全措施（如HTTPS、IP白名单、风控系统）来降低风险。 总结 特性 微信支付签名（对称加密） 电子签名（非对称加密） 性能 高 低 实现复杂度 简单 复杂 安全性 较低（依赖密钥管理） 高 不可否认性 不支持 支持 适用场景 高并发、短周期请求（如支付） 长期有效数据（如合同、证书） 微信支付选择对称加密签名是为了在性能、实现复杂度、业务需求之间找到最佳平衡。虽然对称加密的安全性较低，但通过其他安全措施可以弥补这一不足。而电子签名更适合对安全性和不可否认性要求更高的场景（如法律文件、合同签署）。\n","date":"2025-03-17T14:41:07+08:00","permalink":"https://hollisho.github.io/p/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E7%AD%BE%E5%90%8D%E5%9F%BA%E4%BA%8E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86vs%E7%94%B5%E5%AD%90%E7%AD%BE%E5%90%8D%E5%9F%BA%E4%BA%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/","title":"微信支付签名（基于对称加密）vs电子签名（基于非对称加密）"},{"content":"PHP Helpers PHP Helpers 是一个简单易用的 PHP 工具集合，它提供了许多常用的辅助函数，可以帮助你更快速、更方便地完成 PHP 开发工作。无论你是 PHP 新手还是有经验的开发者，这个工具包都能让你的编码更加高效。\n安装 基本使用方法 1. 在项目中引入 安装完成后，你需要在你的 PHP 文件中引入 Composer 的自动加载文件：\n1 require_once \u0026#39;vendor/autoload.php\u0026#39;; 2. 使用辅助函数 PHP Helpers 提供了多种辅助函数，你可以直接调用它们：\n1 2 3 4 5 // 例如使用数组辅助函数 $result = \\Hollisho\\Helpers\\ArrayHelper::get($array, \u0026#39;user.name\u0026#39;, \u0026#39;默认值\u0026#39;); // 例如使用字符串辅助函数 $slug = \\Hollisho\\Helpers\\StringHelper::slug(\u0026#39;Hello World\u0026#39;); 常用功能示例 数组操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 从多维数组中安全获取值 $user = [ \u0026#39;profile\u0026#39; =\u0026gt; [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;张三\u0026#39;, \u0026#39;age\u0026#39; =\u0026gt; 25 ] ]; // 获取用户名 $name = \\Hollisho\\Helpers\\ArrayHelper::get($user, \u0026#39;profile.name\u0026#39;); echo $name; // 输出: 张三 // 如果键不存在，返回默认值 $address = \\Hollisho\\Helpers\\ArrayHelper::get($user, \u0026#39;profile.address\u0026#39;, \u0026#39;未设置\u0026#39;); echo $address; // 输出: 未设置 1 2 3 4 5 6 7 8 9 10 ### 字符串处理 ```php // 生成URL友好的字符串 $slug = \\Hollisho\\Helpers\\StringHelper::slug(\u0026#39;你好 世界\u0026#39;); echo $slug; // 输出: ni-hao-shi-jie 或类似格式 // 随机字符串生成 $random = \\Hollisho\\Helpers\\StringHelper::random(8); echo $random; // 输出: 类似 a1b2c3d4 的8位随机字符串 日期时间处理 1 2 3 4 5 6 7 // 格式化日期 $formatted = \\Hollisho\\Helpers\\DateHelper::format(\u0026#39;2023-01-01\u0026#39;, \u0026#39;Y年m月d日\u0026#39;); echo $formatted; // 输出: 2023年01月01日 // 获取两个日期之间的天数 $days = \\Hollisho\\Helpers\\DateHelper::diffInDays(\u0026#39;2023-01-01\u0026#39;, \u0026#39;2023-01-10\u0026#39;); echo $days; // 输出: 9 环境变量功能 如果你需要使用环境变量功能（EnvHelper），需要额外安装 vlucas/phpdotenv 扩展：\n1 composer require vlucas/phpdotenv:^5.6 安装后，你可以这样使用：\n1 2 3 4 5 6 // 加载 .env 文件 \\Hollisho\\Helpers\\EnvHelper::load(\u0026#39;/path/to/your/project\u0026#39;); // 获取环境变量 $dbName = \\Hollisho\\Helpers\\EnvHelper::get(\u0026#39;DB_NAME\u0026#39;, \u0026#39;default_db\u0026#39;); echo $dbName; 如何测试 创建一个测试文件，例如 test.php ： 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php // 引入自动加载文件 require_once \u0026#39;vendor/autoload.php\u0026#39;; // 测试数组辅助函数 $array = [\u0026#39;user\u0026#39; =\u0026gt; [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;李四\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;lisi@example.com\u0026#39;]]; $name = \\Hollisho\\Helpers\\ArrayHelper::get($array, \u0026#39;user.name\u0026#39;); echo \u0026#34;用户名: \u0026#34; . $name . \u0026#34;\\n\u0026#34;; // 测试字符串辅助函数 $random = \\Hollisho\\Helpers\\StringHelper::random(10); echo \u0026#34;随机字符串: \u0026#34; . $random . \u0026#34;\\n\u0026#34;; ","date":"2025-03-17T13:49:36+08:00","permalink":"https://hollisho.github.io/p/php%E5%B8%B8%E7%94%A8%E5%8A%A9%E6%89%8B%E7%B1%BB%E5%BA%93php-helpers-%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","title":"PHP常用助手类库PHP Helpers 简介和使用方法"},{"content":"简介 hollisho/http-client 是一个功能强大且易于使用的PHP HTTP客户端库，旨在简化REST API的调用和集成。它提供了灵活的配置选项、中间件支持和基于注解的API定义，让开发者能够更高效地处理HTTP请求。\n主要特性 🚀 支持多种HTTP方法（GET, POST, PUT, DELETE等） 🔧 可扩展的中间件系统 🎯 基于注解的API定义 🛡️ 内置认证支持（Basic Auth） 📦 自动处理JSON请求/响应 ⚡ 兼容PHP 7.x 和 PHP 8.0+ 快速开始 安装 1 composer require hollisho/http-client 基本使用 1 2 3 4 use hollisho\\httpclient\\BaseClient; $httpClient = new BaseClient(\u0026#39;https://api.example.com\u0026#39;); $response = $httpClient-\u0026gt;httpGet(\u0026#39;/users\u0026#39;); 使用注解定义API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * @BaseUrl(host=\u0026#34;https://api.example.com\u0026#34;) */ interface UserService { /** * @Action( * method=@Get, * endpoint=@Endpoint(uri=\u0026#34;/users/{id}\u0026#34;) * ) */ public function getUser($id); } $client = FeignClientFactory::create(UserService::class); $user = $client-\u0026gt;getUser(123); 为什么选择 hollisho/http-client？ 简化开发 ：通过注解自动生成API客户端，减少样板代码 灵活扩展 ：支持自定义中间件，轻松添加日志、缓存等功能 现代PHP支持 ：全面支持PHP 8.0+的新特性 文档完善 ：提供详细的文档和示例代码 活跃维护 ：持续更新和维护，及时修复问题 获取更多信息 GitHub仓库 完整文档 示例代码 立即体验 hollisho/http-client ，让您的PHP HTTP请求处理更加高效便捷！ ","date":"2024-11-11T14:41:07+08:00","permalink":"https://hollisho.github.io/p/%E9%AB%98%E6%95%88php-http%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%93-hollisho/http-client/","title":"高效PHP HTTP客户端库 - hollisho/http-client"},{"content":"Webman框架请求验证器扩展包 本扩展包为Webman框架提供了一个优雅的请求验证解决方案，内置了ThinkPHP验证器，通过依赖注入方式自动生成请求对象，并对对象的字段进行校验。\n安装 通过Composer安装：\n1 composer require hollisho/webman-request 基本使用 定义请求类 首先，创建一个继承自WebmanRequest的请求类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;?php namespace app\\request; use Hollisho\\WebmanRequest\\WebmanRequest; class MyRequest extends WebmanRequest { // 定义请求参数属性 public $id; public $status = 0; // 可以设置默认值 // 定义验证规则 public function rules() { return [ \u0026#39;id\u0026#39; =\u0026gt; \u0026#39;require|number\u0026#39;, \u0026#39;status\u0026#39; =\u0026gt; \u0026#39;require|number\u0026#39;, ]; } // 定义错误消息 protected function messages() { return [ \u0026#39;id.require\u0026#39; =\u0026gt; \u0026#39;id不能为空\u0026#39;, \u0026#39;id.number\u0026#39; =\u0026gt; \u0026#39;id必须为数字\u0026#39;, \u0026#39;status.require\u0026#39; =\u0026gt; \u0026#39;status不能为空\u0026#39;, \u0026#39;status.number\u0026#39; =\u0026gt; \u0026#39;status必须为数字\u0026#39;, ]; } } 在控制器中使用 在控制器中通过依赖注入方式使用请求类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?php namespace app\\controller; use app\\request\\MyRequest; use support\\Response; class IndexController { public function index(MyRequest $request) { // 验证通过后，可以直接使用请求对象的属性 $id = $request-\u0026gt;id; $status = $request-\u0026gt;status; // 业务逻辑处理... return json([\u0026#39;code\u0026#39; =\u0026gt; 0, \u0026#39;msg\u0026#39; =\u0026gt; \u0026#39;success\u0026#39;, \u0026#39;data\u0026#39; =\u0026gt; [ \u0026#39;id\u0026#39; =\u0026gt; $id, \u0026#39;status\u0026#39; =\u0026gt; $status ]]); } } 常用验证规则 本扩展包内置了ThinkPHP验证器的所有验证规则，以下是一些常用的验证规则：\n规则 说明 示例 require 必须填写 \u0026rsquo;name\u0026rsquo; =\u0026gt; \u0026lsquo;require\u0026rsquo; number 必须是数字 \u0026lsquo;age\u0026rsquo; =\u0026gt; \u0026rsquo;number\u0026rsquo; integer 必须是整数 \u0026lsquo;count\u0026rsquo; =\u0026gt; \u0026lsquo;integer\u0026rsquo; float 必须是浮点数 \u0026lsquo;price\u0026rsquo; =\u0026gt; \u0026lsquo;float\u0026rsquo; boolean 必须是布尔值 \u0026lsquo;status\u0026rsquo; =\u0026gt; \u0026lsquo;boolean\u0026rsquo; email 必须是邮箱格式 \u0026rsquo;email\u0026rsquo; =\u0026gt; \u0026rsquo;email\u0026rsquo; array 必须是数组 \u0026rsquo;tags\u0026rsquo; =\u0026gt; \u0026lsquo;array\u0026rsquo; date 必须是日期格式 \u0026lsquo;birthday\u0026rsquo; =\u0026gt; \u0026lsquo;date\u0026rsquo; alpha 必须是字母 \u0026rsquo;name\u0026rsquo; =\u0026gt; \u0026lsquo;alpha\u0026rsquo; alphaNum 必须是字母和数字 \u0026lsquo;account\u0026rsquo; =\u0026gt; \u0026lsquo;alphaNum\u0026rsquo; alphaDash 必须是字母、数字、下划线或破折号 \u0026lsquo;username\u0026rsquo; =\u0026gt; \u0026lsquo;alphaDash\u0026rsquo; chs 必须是中文 \u0026rsquo;name\u0026rsquo; =\u0026gt; \u0026lsquo;chs\u0026rsquo; chsAlpha 必须是中文或字母 \u0026rsquo;name\u0026rsquo; =\u0026gt; \u0026lsquo;chsAlpha\u0026rsquo; chsAlphaNum 必须是中文、字母或数字 \u0026rsquo;name\u0026rsquo; =\u0026gt; \u0026lsquo;chsAlphaNum\u0026rsquo; chsDash 必须是中文、字母、数字、下划线或破折号 \u0026rsquo;name\u0026rsquo; =\u0026gt; \u0026lsquo;chsDash\u0026rsquo; url 必须是URL地址 \u0026lsquo;website\u0026rsquo; =\u0026gt; \u0026lsquo;url\u0026rsquo; ip 必须是IP地址 \u0026lsquo;ip\u0026rsquo; =\u0026gt; \u0026lsquo;ip\u0026rsquo; mobile 必须是手机号码 \u0026lsquo;mobile\u0026rsquo; =\u0026gt; \u0026lsquo;mobile\u0026rsquo; idCard 必须是身份证号码 \u0026lsquo;idcard\u0026rsquo; =\u0026gt; \u0026lsquo;idCard\u0026rsquo; zipCode 必须是邮政编码 \u0026lsquo;zipcode\u0026rsquo; =\u0026gt; \u0026lsquo;zipCode\u0026rsquo; in 必须在范围内 \u0026rsquo;type\u0026rsquo; =\u0026gt; \u0026lsquo;in:1,2,3\u0026rsquo; notIn 必须不在范围内 \u0026rsquo;type\u0026rsquo; =\u0026gt; \u0026rsquo;notIn:1,2,3\u0026rsquo; between 必须在范围内 \u0026lsquo;age\u0026rsquo; =\u0026gt; \u0026lsquo;between:18,60\u0026rsquo; notBetween 必须不在范围内 \u0026lsquo;age\u0026rsquo; =\u0026gt; \u0026rsquo;notBetween:0,17\u0026rsquo; length 长度必须在范围内 \u0026rsquo;name\u0026rsquo; =\u0026gt; \u0026rsquo;length:2,20\u0026rsquo; max 最大长度 \u0026rsquo;name\u0026rsquo; =\u0026gt; \u0026lsquo;max:20\u0026rsquo; min 最小长度 \u0026lsquo;password\u0026rsquo; =\u0026gt; \u0026lsquo;min:6\u0026rsquo; after 必须在日期之后 \u0026lsquo;begin_time\u0026rsquo; =\u0026gt; \u0026lsquo;after:2020-01-01\u0026rsquo; before 必须在日期之前 \u0026rsquo;end_time\u0026rsquo; =\u0026gt; \u0026lsquo;before:2030-01-01\u0026rsquo; confirm 必须和指定字段相同 \u0026lsquo;repassword\u0026rsquo; =\u0026gt; \u0026lsquo;confirm:password\u0026rsquo; different 必须和指定字段不同 \u0026rsquo;nickname\u0026rsquo; =\u0026gt; \u0026lsquo;different:username\u0026rsquo; eq 必须等于指定值 \u0026lsquo;status\u0026rsquo; =\u0026gt; \u0026rsquo;eq:1\u0026rsquo; neq 必须不等于指定值 \u0026lsquo;status\u0026rsquo; =\u0026gt; \u0026rsquo;neq:0\u0026rsquo; gt 必须大于指定值 \u0026lsquo;age\u0026rsquo; =\u0026gt; \u0026lsquo;gt:18\u0026rsquo; lt 必须小于指定值 \u0026lsquo;age\u0026rsquo; =\u0026gt; \u0026rsquo;lt:60\u0026rsquo; egt 必须大于等于指定值 \u0026lsquo;age\u0026rsquo; =\u0026gt; \u0026rsquo;egt:18\u0026rsquo; elt 必须小于等于指定值 \u0026lsquo;age\u0026rsquo; =\u0026gt; \u0026rsquo;elt:60\u0026rsquo; regex 必须满足正则表达式 \u0026lsquo;zip\u0026rsquo; =\u0026gt; \u0026lsquo;regex:/^\\d{6}$/\u0026rsquo; 总结 hollisho/webman-request扩展包为Webman框架提供了一个强大而灵活的请求验证解决方案，通过依赖注入的方式自动验证请求参数，使代码更加简洁和易于维护。它支持多种验证规则、自定义验证规则、验证场景等高级功能，能够满足各种复杂的验证需求。\n参考链接 Webman官方文档 ThinkPHP验证器文档 特别说明 由于thinkphp验证器的原因，本扩展包不支持php8.0以上的版本，请在使用前确认您的PHP版本。 本扩展包仅提供了基本的请求验证功能，对于更复杂的验证需求，您可以根据实际情况自行扩展。（例如场景的支持目前尚未支持） ","date":"2024-10-21T14:13:57+08:00","permalink":"https://hollisho.github.io/p/webman%E6%A1%86%E6%9E%B6%E8%AF%B7%E6%B1%82%E9%AA%8C%E8%AF%81%E5%99%A8%E6%89%A9%E5%B1%95%E5%8C%85/","title":"Webman框架请求验证器扩展包"},{"content":"插件目录结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 ./htranslate ├── db/ │ ├── migrations/ │ │ └── xxxxxx_migration.php //数据库迁移文件 ├── inc/ │ ├── Api/ //WordPress提供的API │ │ ├── CustomizeApi.php // 主题自定义API │ │ └── SettingsApi.php // 后台界面自定义API │ ├── Base/ │ │ ├── BaseAdminPage.php // WordPress后台页面基础类 │ │ └── Common.php // 插件公共信息 │ ├── Exceptions/ // 异常类 │ │ ├── InvalidArgumentException.php │ ├── Handlers/ │ │ ├── Activate.php // 插件启动执行脚本 │ │ └── Deactivate.php // 插件禁用执行脚本 │ ├── Helpers/ │ │ ├── ArrayHelper.php // 数组操作助手类 │ │ ├── AssetsHelper.php // Assets资源路径助手类 │ │ ├── DomHelper.php // DOM助手类 │ │ └── helpers.php // 插件公共方法 │ ├── Http/ │ │ ├── Controllers │ │ │ ├── BaseController.php // 控制器基类 │ │ │ ├── CommonController.php // 公共操作 │ │ │ ├── ImproveController.php // 翻译改进 │ │ │ ├── PageController.php // 后台页面 │ │ │ └── TestController.php // 测试操作 │ │ ├── Filters //HTTP过滤器 │ │ │ ├── AuthFilter.php // 授权过滤器 │ │ │ ├── FilterInterface.php │ │ │ └── FilterPipeline.php // 过滤器管道 │ │ ├── Views │ │ │ ├── Vo/ // ValueObject用于规范化输出结果 │ │ │ ├── HttpView.php // 普通页面视图 │ │ │ ├── JsonViewTrait.php // Json视图 │ │ │ └── TeamoneViewTrait.php // 霆万模板引擎视图 │ ├── Infrastructure/ // 基础设施层 │ │ │ ├── Components/ // 通用组件 │ │ │ ├── Models/ // 数据表模型 │ │ │ ├── Providers/ // 服务提供者，用于扩展第三方服务支持 │ │ │ │ ├── HoTemplateServiceProvider.php // 引入Ho模板引擎 │ │ │ └── Repositories/ // 仓储层 │ ├── Services/ // 应用服务层 │ ├── WPProviders/ // WP功能服务提供者 │ │ │ ├── AddAdminMenuPage.php // 注册后台管理菜单 │ │ │ ├── RegisterAdminScripts.php // 加载后台静态资源文件 │ │ │ └── RegisterRoute.php // 注册WP路由 │ └── Pages/ // WP后台菜单对应的页面 │ ├── Dashboard.php // 首页 │ ├── Settings.php // 设置 │ └── Hosting.php // 语言托管 ├── resources/ // 静态资源目录 │ ├── css/ │ └── js / ├── templates/ // 页面模板文件目录 ├── htranslate.php // 插件入口文件 └── composer.json 架构设计图 ","date":"2024-05-26T10:23:04+08:00","permalink":"https://hollisho.github.io/p/wordpress%E6%8F%92%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","title":"Wordpress插件架构设计"},{"content":"Singular Page:详情页 Single Post Page：Attachment Post、Custom Post、Blog Post\nStatic Page：Page Template\npost模板文件加载顺序 $customer.php-\u0026gt;single-post.php-\u0026gt;single.php-\u0026gt;singular.php-\u0026gt;index.php\npage模板文件加载顺序 $customer.php-\u0026gt;page-$slug.php-\u0026gt;page-$id.php-\u0026gt;page.php-\u0026gt;singular.php-\u0026gt;index.php\nattachment模板文件加载顺序 $mimetype-$subtype.php-\u0026gt;$subtype.php-\u0026gt;$mimetype.php-\u0026gt;attachment.php-\u0026gt;single.php-\u0026gt;singular.php-\u0026gt;index.php\nArchive Page：归档页 Category Archive分类目录模板加载顺序 category-$slug.php-\u0026gt;category-$id.php-\u0026gt;category.php-\u0026gt;archive.php-\u0026gt;index.php\nTag Archive标签模板加载顺序 tag-$slug.php-\u0026gt;tag-$id.php-\u0026gt;tag.php-\u0026gt;archive.php-\u0026gt;index.php\nAuthor Archive作者归档页模板加载顺序 author-$nicename.php-\u0026gt;author-$id.php-\u0026gt;author.php-\u0026gt;archive.php-\u0026gt;index.php\nDate Archive日期归档页模板加载顺序 YearArchive-\u0026gt;date.php-\u0026gt;archive.php-\u0026gt;index.php\nMonthArchive-\u0026gt;date.php-\u0026gt;archive.php-\u0026gt;index.php\nDayArchive-\u0026gt;date.php-\u0026gt;archive.php-\u0026gt;index.php\nSite Front Page：首页 Page Shown On Front 表示在设置-\u0026gt;阅读设置-\u0026gt;首页指定为静态页面\nPosts Shown On Front 表示在设置-\u0026gt;阅读设置-\u0026gt;首页指定为最新文章\nBlog Posts Index Page 表示在设置-\u0026gt;阅读设置-\u0026gt;指定的文章页\nFront-page.php-\u0026gt;Posts Shown On Front-\u0026gt;home.php-\u0026gt;index.php\nFront-page.php-\u0026gt;Page Shown On Front-\u0026gt;page-$slug.php-\u0026gt;page-$id.php-\u0026gt;page.php-\u0026gt;singular.php-\u0026gt;index.php\nBlog Posts Index Page-\u0026gt;home.php-\u0026gt;index.php\n404 Page 404.php-\u0026gt;index.php\nSearch Page search.php-\u0026gt;index.php\nEmbed Page嵌入页面 embed-$post-type-$post-format.php-\u0026gt;embed-$post-type.php-\u0026gt;embed.php-\u0026gt;wp-include/theme-compat/embed.php\n自定义内容详情页 $customer.php-\u0026gt;single-$posttype-$slug.php-\u0026gt;single-$posttype.php-\u0026gt;single.php-\u0026gt;singular.php-\u0026gt;index.php\n自定义内容归档页 archvice-$posttype.php-\u0026gt;archive.php-\u0026gt;index.php\n自定义分类项目归档页 taxonomy-$taxonomy-$term.php-\u0026gt;taxonomy-$taxonomy.php-\u0026gt;taxonomy.php-\u0026gt;archive.php-\u0026gt;index.php\nwordpress模板层级图 ","date":"2024-04-20T12:14:46+08:00","permalink":"https://hollisho.github.io/p/wordpress%E4%B8%BB%E9%A2%98%E6%A8%A1%E6%9D%BF%E5%B1%82%E7%BA%A7/","title":"Wordpress主题模板层级"},{"content":"","date":"2024-04-18T13:36:19+08:00","permalink":"https://hollisho.github.io/p/wordpress%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","title":"Wordpress页面生命周期"},{"content":"内容类型和分类方式 Debug Bar插件 Queries WP Query Object Cache Post Types Post Type 内容类型 Taxonomy 分类方式 category 分类目录 post_tag 标签 Debug Bar Taxonomy插件可以查看所有分类方式 最小主题 style.css 必填字段: Theme Name、Author、Description、Version、License、License URI、Text Domain\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* Theme Name: Mini Theme Theme URI: 主题的详细介绍的网址，仅在官方主题库中才会用到 Author: Hollis Author URI: http://www.1024plus.com Description: 最小主题 Version: 1.0.0 License: 主题的版权信息 License URI: 版权详情网址 Text Domain: 国际化相关 Tags: 标签，方便用于在官方主题库中筛选 Domain Paths: 语言包路径 */ index.php 详情页模板层级 文章详情页 1 2 3 4 5 $custom.php single-post.php single.php singular.php index.php 附件详情页 wp_posts表中post_mime_type记录了attachment的mimetype\n如：image/png，其中mimetype是image，subtype是png\n上传附件可能有大小限制，可以修改php.ini中的post_max_size\n1 2 3 4 5 6 7 $mimetype-$subtype.php $subtype.php $mimetype.php attachment.php single.php singular.php index.php 自定义内容类型详情页 1 2 3 4 5 6 $custom.php single-$posttype-$slug.php single-$posttype.php single.php singular.php index.php 页面详情页 Custom Template 采用了自定义模板 1 $custom.php 如果页面对应的自定义模板被删除了，但是数据中的对应关系还在，则按以下规则加载模板\n1 2 3 page.php singular.php index.php Default Template 采用了默认模板 1 2 3 4 5 page-$slug.php page-$id.php page.php singular.php index.php 自定义模板文件 Template Post Type 可以为空，默认只支持page\n1 2 3 4 5 6 7 \u0026lt;?php /* Template Name: 自定义模板 Template Post Type: post,page,product */ ?\u0026gt; 分类目录归档页 Category Archice 1 2 3 4 5 category-$slug.php category-$id.php category.php archive.php index.php Tag Archive 1 2 3 4 5 tag-$slug.php tag-$id.php tag.php archive.php index.php Author Archive 1 2 3 4 5 author-$nicename.php author-$id.php author.php archive.php index.php Date Archive (Year Archive、Month Archive、Day Archive) 可以通过小工具，进入到日期归档页\n1 2 3 date.php archive.php index.php 自定义内容归档页(custom post type) 1 2 3 archive-$posttype.php archive.php index.php 自定义分类方式归档页(custom taxonomy) 如：自定义产品分类product_cat，其中有phone、pc两个分类项目，则$taxonomy为product_cat、$term为phone和pc\n1 2 3 4 5 taxonomy-$taxonomy-$term.php taxonomy-$taxonomy.php taxonomy.php archive.php index.php 站点首页模板层级 Posts show on front（默认设置） 1 2 3 front-page.php home.php index.php Page show on front（一个静态页面） 1 2 front-page.php 后面的模板层级和页面详情页一致 Blog Post Index Page(指定为文章页的页面) 1 2 home.php index.php 404错误页、搜索结果页、被嵌入内容页 404错误页 1 2 404.php index.php 搜索结果页 1 2 search.php index.php 归档页默认查询结果 分类目录归档页 queried_object (WP_Term) 分类目录信息 - 日期分类归档页没有queried_object字段 queried_object_id 分类目录id posts 归档页的文章信息数组 post (WP_Post) 当前文章信息 is_archive = 1 归档页 is_category = 1 分类目录归档页 详情页默认查询结果 文章详情页 queried_object 文章信息 queried_object_id 文章id posts 数组里面只有一个文章信息 post 当前文章信息 is_single = 1 内容详情页 is_singular = 1 详情页 首页和其他页面默认查询结果 首页（默认） posts 最新发布的文章信息数组 post 当前文章信息 is_home = 1 首页（设置了自定义页面） posts 自定义页面的信息，数组只有一个元素 post 自定义页面的信息 queried_object 自定义页面的信息 queried_object_id 自定义页面id is_page = 1 is_singular = 1 详情页 Blog文章索引页（就是在阅读设置中，文章页指定了自定义页面） queried_object 自定义页面的信息 queried_object_id 自定义页面id posts 最新发布的文章信息数组 post 当前文章信息 is_home = 1 is_posts_page = 1 搜索结果页 posts 搜索结果的所有文章信息数组 post 当前文章信息 is_search = 1 404错误页 is_404 = 1 获取文章各种数据的模板标签 获取内容并输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //文章ID the_ID(); //文章标题 the_title(); //文章内容 the_content(); //文章摘要。如果没有设置摘要，会自动截取一部分内容作为摘要 the_excerpt(); //获取作者信息 the_author(); //获取文章的网址 the_permalink(); //发布时间。 //时间格式可以在设置-\u0026gt;常规中设置 //也可以指定格式the_time(\u0026#39;Y-m-d H:i:s\u0026#39;); the_time(); 获取内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //文章ID get_the_ID(); //文章标题 get_the_title(); //文章内容 get_the_content(); //文章摘要。如果没有设置摘要，会自动截取一部分内容作为摘要 get_the_excerpt(); //获取作者信息 get_the_author(); //作者归档页超链接。用户名+超链接 get_the_author_link(); //获取文章别名。自带了urlencode。使用的时候需要urldecode global $post; $post-\u0026gt;post_name; //获取文章的网址 get_the_permalink(); //发布时间。 //时间格式可以在设置-\u0026gt;常规中设置 //也可以指定格式get_the_time(\u0026#39;Y-m-d H:i:s\u0026#39;); get_the_time(); //获取文章评论数量 get_comments_number(); 获取文章所属的分类目录信息 the_category 获取内容并输出 get_the_category_list 获取内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * @param string $separator 默认以⽆序列表输出分类链接，当⽂章指定了多个分类时，提供⼀个字符⽤于分隔这些分类链接。 * @param string $parents \u0026#39;\u0026#39;：不显示父类信息； \u0026#39;multiple\u0026#39;：显示父类信息，分开显示(有各自的超链接)； \u0026#39;single\u0026#39;：显示父类信息，与子类合并显示(公用一个超链接) * @param int $post_id 在have_posts() 循环中使用时，不要传值，否则需要传入指定post_id * * 例子: * the_category(\u0026#39;,\u0026#39;, \u0026#39;multiple\u0026#39;); * 输出：\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;体育\u0026lt;/a\u0026gt;,\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;篮球\u0026lt;/a\u0026gt; * the_category(\u0026#39;,\u0026#39;, \u0026#39;single\u0026#39;); * 输出：\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;体育,篮球\u0026lt;/a\u0026gt; * */ function the_category( $separator = \u0026#39;\u0026#39;, $parents = \u0026#39;\u0026#39;, $post_id = false ) { echo get_the_category_list( $separator, $parents, $post_id ); } get_the_category（纯数据，不带html标签） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * WP_Term Object * * term_id 分类ID * name 分类名称 * slug 分类别名 * description 分类描述 * taxonomy 分类项目的分类方式 category * ...... */ $categorys = get_the_category(); foreach ($categorys as $category) { \u0026lt;p\u0026gt;编号：\u0026lt;?php echo $category-\u0026gt;term_id; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;名称：\u0026lt;?php echo $category-\u0026gt;name; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;别名：\u0026lt;?php echo $category-\u0026gt;slug; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;描述：\u0026lt;?php echo $category-\u0026gt;description; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;⽹址：\u0026lt;?php echo get_category_link($category); ?\u0026gt;\u0026lt;/p\u0026gt; } 获取文章所属标签信息 the_tags 获取标签并输出 get_the_tag_list 获取标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * @param string $before 标签链接前的内容 * @param string $sep 多个标签之间的分隔符，默认为\u0026#39;,\u0026#39; * @param string $after 标签链接后的内容 */ function the_tags( $before = null, $sep = \u0026#39;, \u0026#39;, $after = \u0026#39;\u0026#39; ) { if ( null === $before ) { $before = __( \u0026#39;Tags: \u0026#39; ); } $the_tags = get_the_tag_list( $before, $sep, $after ); if ( ! is_wp_error( $the_tags ) ) { echo $the_tags; } } /** * $post_id 文章id */ function get_the_tag_list( $before = \u0026#39;\u0026#39;, $sep = \u0026#39;\u0026#39;, $after = \u0026#39;\u0026#39;, $post_id = 0 ) get_the_tags（纯数据，不带html标签） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * WP_Term Object * * term_id 分类ID * name 分类名称 * slug 分类别名 * description 分类描述 * taxonomy 分类项目的分类方式 post_tag * ...... */ $posttags = get_the_tags(); if ($posttags) foreach($posttags as $tag) { echo \u0026#39;标签ID：\u0026#39; . $tag-\u0026gt;term_id; echo \u0026#39;\u0026lt;br /\u0026gt;标签名称：\u0026#39; . $tag-\u0026gt;name; echo \u0026#39;\u0026lt;br /\u0026gt;标签描述：\u0026#39; . $tag-\u0026gt;description; echo \u0026#39;\u0026lt;br /\u0026gt;标签网址：\u0026#39; . get_tag_link($tag); } 分类归档页中调用和显示数据 Category Archive 分类目录归档页 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //获取分类目录信息 $category = get_queried_object(); \u0026lt;p\u0026gt;编号：\u0026lt;?php echo $category-\u0026gt;term_id; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;名称：\u0026lt;?php echo $category-\u0026gt;name; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;别名：\u0026lt;?php echo $category-\u0026gt;slug; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;描述：\u0026lt;?php echo $category-\u0026gt;description; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;⽹址：\u0026lt;?php echo get_category_link($category); ?\u0026gt;\u0026lt;/p\u0026gt; //获取分类目录下面的文章信息 \u0026lt;?php if( have_posts() ): ?\u0026gt; \u0026lt;?php while( have_posts() ): the_post(); ?\u0026gt; \u0026lt;?php the_author(); //作者名称 ?\u0026gt; \u0026lt;?php the_title(); //标题 ?\u0026gt; \u0026lt;?php the_content(); //正文 ?\u0026gt; \u0026lt;?php echo get_comments_number(); //评论数量 ?\u0026gt; \u0026lt;?php endwhile; ?\u0026gt; \u0026lt;?php endif; ?\u0026gt; Tag Archive 标签归档页 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //获取标签信息 $tag = get_queried_object(); \u0026lt;p\u0026gt;编号：\u0026lt;?php echo $tag-\u0026gt;term_id; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;名称：\u0026lt;?php echo $tag-\u0026gt;name; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;别名：\u0026lt;?php echo $tag-\u0026gt;slug; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;描述：\u0026lt;?php echo $tag-\u0026gt;description; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;⽹址：\u0026lt;?php echo get_tag_link($tag); ?\u0026gt;\u0026lt;/p\u0026gt; //获取标签目录下面的文章信息 \u0026lt;?php if( have_posts() ): ?\u0026gt; \u0026lt;?php while( have_posts() ): the_post(); ?\u0026gt; \u0026lt;?php the_author(); //作者名称 ?\u0026gt; \u0026lt;?php the_title(); //标题 ?\u0026gt; \u0026lt;?php the_content(); //正文 ?\u0026gt; \u0026lt;?php echo get_comments_number(); //评论数量 ?\u0026gt; \u0026lt;?php endwhile; ?\u0026gt; \u0026lt;?php endif; ?\u0026gt; Author Archive 作者归档页 1 2 3 4 5 6 7 8 9 //获取作者信息 $author = get_queried_object(); \u0026lt;p\u0026gt;作者用户名：\u0026lt;?php echo $author-\u0026gt;user_login; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;作者ID：\u0026lt;?php echo $author-\u0026gt;ID; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;作者邮箱：\u0026lt;?php echo $author-\u0026gt;user_email; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;作者显示名：\u0026lt;?php echo $author-\u0026gt;user_display; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;作者归档页网址：\u0026lt;?php echo get_the_author_posts_link(); ?\u0026gt;\u0026lt;/p\u0026gt; //获取文章信息同上 Date Archive 日期归档页 1 2 3 4 5 6 7 //日期归档页无法获取get_queried_object //获取日期信息 echo get_the_date(); //可以自定义日期格式 echo get_the_date(\u0026#39;Y-d-m\u0026#39;); //获取文章信息同上 通用获取分类title 1 2 3 4 //直接使用 the_archive_title(); //或者 echo get_the_archive_title(); 搜索结果归档页 1 2 3 4 5 //日期归档页无法获取get_queried_object //获取搜索结果页搜索关键字 $key = get_search_query(); //获取文章信息同上 模板标签所在的文件 模板标签所在的文件，都有一个相同的后缀*-template.php，用于区分模板文件和其他文件。\n总共有9个模板文件：\n1 2 3 4 5 6 7 8 9 wp-includes/general-template.php wp-includes/author-template.php wp-includes/bookmark-template.php wp-includes/category-template.php wp-includes/comment-template.php wp-includes/link-template.php wp-includes/post-template.php wp-includes/post-thumbnail-template.php wp-includes/nav-menu-template.php 条件标签使用举例 1 2 3 4 5 6 7 8 9 \u0026lt;?php if (is_year()) { echo get_the_date(\u0026#39;Y\u0026#39;); } elseif (is_month()) { echo get_the_date(\u0026#39;Y-m\u0026#39;); } elseif (is_day()) { echo get_the_date(\u0026#39;Y-m-d\u0026#39;); } ?\u0026gt; 首页相关条件标签 is_home is_front_page 如果首页采用了默认页面，则：\n1 2 is_home: true is_front_page: true 如果首页设置了指定页面，则：\n1 2 is_home: false is_front_page: true 获取其他信息 获取站点信息 关键函数 1 2 3 4 5 6 7 /** * @see get_bloginfo() For possible `$show` values * @param string $show Optional. Site information to display. Default empty. */ function bloginfo( $show = \u0026#39;\u0026#39; ) { echo get_bloginfo( $show, \u0026#39;display\u0026#39; ); } 通用信息 1 2 3 4 5 6 7 8 9 10 11 //站点标题 get_bloginfo(\u0026#39;name\u0026#39;); get_bloginfo(\u0026#39;blogname\u0026#39;); //站点描述 get_bloginfo(\u0026#39;description\u0026#39;); //站点首页网址，等同于site_url() get_bloginfo(\u0026#39;wpurl\u0026#39;); //站点首页网址，等同于home_url() get_bloginfo(\u0026#39;url\u0026#39;); //站点管理员邮箱 get_bloginfo(\u0026#39;admin_email\u0026#39;); 评论信息 1 2 3 4 5 6 \u0026lt;?php if (comments_open() || get_commments_number()) { //如果文章允许评论被关闭，则只显示历史评论列表，不显示评论发表框 comments_template(); } ?\u0026gt; 主题路径及url信息 1 2 3 4 //获取当前主题所在目录的网址 get_theme_file_uri() //获取当前主题所在目录的绝对路径 get_theme_file_path() 钩子机制 动作钩子 1 add_action(\u0026#39;hook_name\u0026#39;, \u0026#39;your_func\u0026#39;); 过滤器钩子 1 add_filter(\u0026#39;hook_name\u0026#39;, \u0026#39;your_func\u0026#39;); 传统引入css和js文件的方式 内联 1 \u0026lt;div style=\u0026#34;width: 65px;height: 20px;border: 1px solid;\u0026#34;\u0026gt;测试元素\u0026lt;/div\u0026gt; 页联 1 2 3 4 5 6 7 8 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; div { width: 65px; height: 20px; border: 1px solid; background: greenyellow; } \u0026lt;/style\u0026gt; 外联 1 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;*.css\u0026#34; /\u0026gt; 推荐的引入css和js文件的方式 引入css文件 1 2 3 4 5 6 7 8 9 /** * 引入css文件 * @param string $handle Name of the stylesheet. Should be unique. * @param string $src * @param string[] $deps * @param string|bool|null $ver * @param string $media */ function wp_enqueue_style( $handle, $src = \u0026#39;\u0026#39;, $deps = array(), $ver = false, $media = \u0026#39;all\u0026#39; ) 引入js文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 引入js文件 wp 6.3.0版本之后，$in_footer参数改成了$args * @since 6.3.0 The $in_footer parameter of type boolean was overloaded to be an $args parameter of type array. * @param string $handle Name of the script. Should be unique. * @param string $src Default empty. * @param string[] $deps * @param string|bool|null $ver * @param array|bool $args { * Optional. An array of additional script loading strategies. Default empty array. * Otherwise, it may be a boolean in which case it determines whether the script is printed in the footer. Default false. * * @type string $strategy Optional. If provided, may be either \u0026#39;defer\u0026#39; or \u0026#39;async\u0026#39;. * @type bool $in_footer Optional. Whether to print the script in the footer. Default \u0026#39;false\u0026#39;. * } */ function wp_enqueue_script( $handle, $src = \u0026#39;\u0026#39;, $deps = array(), $ver = false, $args = array() ) 使用案例 1 2 3 4 add_action(\u0026#39;wp_enqueue_scripts\u0026#39;, function () { wp_enqueue_style(\u0026#39;common-style\u0026#39;, get_theme_file_uri() . \u0026#39;/css/commom.css\u0026#39;); wp_enqueue_script(\u0026#39;commmon-js\u0026#39;, get_theme_file_uri() . \u0026#39;/js/common.js\u0026#39;, array(), \u0026#39;\u0026#39;, true); }) 模板文件拆分和引入 传统的引入方式 1 2 3 include \u0026#39;template-part.php\u0026#39;; //or require \u0026#39;template-part.php\u0026#39;; wp推荐方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //加载任意模板文件 get_template_part(\u0026#39;template-part\u0026#39;); //加载主题中header.php or header-$name.php get_header($name = \u0026#39;\u0026#39;) //加载主题中footer.php or footer-$name.php get_footer($name = \u0026#39;\u0026#39;) //加载主题中sidebar.php or sidebar-$name.php get_sidebar($name = \u0026#39;\u0026#39;) 分页导航 内容分页 1 2 3 //1.手动插入分页符 //2.通过wp_link_pages()显示页码 wp_link_pages(); 关联分页 获取上一篇文章链接 1 2 3 4 5 6 7 8 9 10 11 12 /** * @see get_previous_post_link() * * @param string $format Optional. Link anchor format. Default \u0026#39;\u0026amp;laquo; %link\u0026#39;. * @param string $link Optional. Link permalink format. Default \u0026#39;%title\u0026#39;. * @param bool $in_same_term Optional. Whether link should be in the same taxonomy term. * Default false. * @param int[]|string $excluded_terms Optional. Array or comma-separated list of excluded term IDs. * Default empty. * @param string $taxonomy Optional. Taxonomy, if `$in_same_term` is true. Default \u0026#39;category\u0026#39;. */ function previous_post_link( $format = \u0026#39;\u0026amp;laquo; %link\u0026#39;, $link = \u0026#39;%title\u0026#39;, $in_same_term = false, $excluded_terms = \u0026#39;\u0026#39;, $taxonomy = \u0026#39;category\u0026#39; ) 获取下一篇文章链接 1 2 3 4 5 6 7 8 9 10 11 12 /** * @see get_next_post_link() * * @param string $format Optional. Link anchor format. Default \u0026#39;\u0026amp;laquo; %link\u0026#39;. * @param string $link Optional. Link permalink format. Default \u0026#39;%title\u0026#39;. * @param bool $in_same_term Optional. Whether link should be in the same taxonomy term. * Default false. * @param int[]|string $excluded_terms Optional. Array or comma-separated list of excluded term IDs. * Default empty. * @param string $taxonomy Optional. Taxonomy, if `$in_same_term` is true. Default \u0026#39;category\u0026#39;. */ function next_post_link( $format = \u0026#39;%link \u0026amp;raquo;\u0026#39;, $link = \u0026#39;%title\u0026#39;, $in_same_term = false, $excluded_terms = \u0026#39;\u0026#39;, $taxonomy = \u0026#39;category\u0026#39; ) 使用举例 1 2 3 4 5 6 7 8 9 \u0026lt;?php if (have_posts()) :?\u0026gt; \u0026lt;?php while (have_posts()) : the_post(); ?\u0026gt; \u0026lt;?php the_content(); ?\u0026gt; \u0026lt;?php wp_link_pages(); ?\u0026gt; \u0026lt;?php endwhile; ?\u0026gt; \u0026lt;?php endif; ?\u0026gt; \u0026lt;?php previous_post_link(\u0026#39;上⼀篇：%link\u0026#39;); ?\u0026gt; \u0026lt;?php next_post_link(\u0026#39;下⼀篇：%link\u0026#39;); ?\u0026gt; 列表分页 简单分页 1 2 3 4 5 6 7 8 9 10 \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;分别获取上⼀⻚和下⼀⻚的链接\u0026lt;/p\u0026gt; \u0026lt;?php previous_posts_link(); ?\u0026gt; \u0026lt;?php next_posts_link(); ?\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;同时获取上下⻚的链接\u0026lt;/p\u0026gt; \u0026lt;?php posts_nav_link(); ?\u0026gt; \u0026lt;/div\u0026gt; 数字分页 1 2 3 4 5 6 7 \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;推荐的数字分⻚函数执⾏的效果\u0026lt;/p\u0026gt; \u0026lt;?php the_posts_pagination(); ?\u0026gt; \u0026lt;/div\u0026gt; //wp 4.1之前的方式 \u0026lt;?php echo paginate_links(); ?\u0026gt; 开启自动生成页面标题功能 1 2 3 4 5 add_action(\u0026#39;after_setup_theme\u0026#39;, function () { add_theme_support(\u0026#39;title-tag\u0026#39;); }); //通过wp_head();触发显示 导航菜单功能 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //1.主题的functions.php中注册菜单 add_action(\u0026#39;after_setup_theme\u0026#39;, function () { //注册导航菜单，用于关联后台设置的菜单，这里nav-1相当于一个标识符，和前台wp_nav_menu的theme_location对应 register_nav_menus([ \u0026#39;nav-1\u0026#39; =\u0026gt; \u0026#39;顶部导航\u0026#39; ]); }) //2.前台显示菜单 \u0026lt;?php wp_nav_menu([ \u0026#39;theme_location\u0026#39; =\u0026gt; \u0026#39;nav-1\u0026#39; ]); ?\u0026gt; wp_nav_menu详细参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $defaults = array( \u0026#39;theme_location\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //调⽤菜单的名称，名称是你⾃⼰注册菜单的时候⾃定义的 \u0026#39;menu\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //使⽤导航菜单的名称调⽤菜单，可以是 ID、别名和名字（按顺序匹配） \u0026#39;container\u0026#39; =\u0026gt; \u0026#39;div\u0026#39;, //最外层容器的标签，只⽀持 div 和 nav 标签 \u0026#39;container_class\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //外层容器的class \u0026#39;container_id\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //外层容器的 ID \u0026#39;menu_class\u0026#39; =\u0026gt; \u0026#39;menu\u0026#39;, //ul ⽗节点的 class 属性 \u0026#39;menu_id\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //ul ⽗节点的 id 属性 \u0026#39;echo\u0026#39; =\u0026gt; true, //布尔值，是否输出菜单，为false是可以⽤于赋值 \u0026#39;fallback_cb\u0026#39; =\u0026gt; \u0026#39;wp_page_menu\u0026#39;, //当前设置的菜单不存在时，显⽰此处设置的菜单 \u0026#39;before\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //显⽰在每个菜单链接前的⽂本 \u0026#39;after\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //显⽰在每个菜单链接后的⽂本 \u0026#39;link_before\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //显⽰在每个菜单链接⽂本前的⽂本 \u0026#39;link_after\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //显⽰在每个菜单链接⽂本后的⽂本 \u0026#39;items_wrap\u0026#39; =\u0026gt; \u0026#39;\u0026lt;ul class=\u0026#34;%1$s\u0026#34; id=\u0026#34;%2$s\u0026#34;\u0026gt;%3$s \u0026lt;/ul\u0026gt;\u0026#39;, //菜单的输出结构， \u0026#39;depth\u0026#39; =\u0026gt; 0, //显⽰菜单深度，0为显⽰所有 \u0026#39;walker\u0026#39; =\u0026gt; \u0026#39;\u0026#39; //菜单的结构对象 通过改参数可以制作任意结构的导航菜单 ); wp_nav_menu( $defaults); 边栏工具功能 开启边栏工具 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 add_action(\u0026#39;widgets_init\u0026#39;, function () { register_sidebar([ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;边栏1\u0026#39;, //⼩⼯具的区域名称，默认是 \u0026#39;sidebar\u0026#39; 加 数字 ID,如：sidebar-1 \u0026#39;id\u0026#39;=\u0026gt; \u0026#39;footer_area_one\u0026#39;, //区域的ID，默认是⼀个⾃动递增的数字 ID \u0026#39;description\u0026#39;=\u0026gt; \u0026#39;第1个边栏\u0026#39;, //区域的描述，默认为空 \u0026#39;before_widget\u0026#39; =\u0026gt; \u0026#39;\u0026lt;section id=\u0026#34;%1$s\u0026#34; class=\u0026#34;%2$s widget\u0026#34;\u0026gt;\u0026#39;, //区域的内容前的HTML代码，默认： \u0026#39;\u0026#39;） \u0026#39;after_widget\u0026#39;=\u0026gt; \u0026#39;\u0026#39;, //区域内容后的HTML代码，默认： \u0026#34;\\n\u0026#34; \u0026#39;before_title\u0026#39;=\u0026gt; \u0026#39;\u0026#39;, //区域标题前的HTML代码，默认： \u0026#39;after_title\u0026#39;=\u0026gt; \u0026#39;\u0026#39;, //区域标题后的HTML代码，默认：\u0026#34;\\n\u0026#34; ]); }); 前台显示指定边栏 1 2 3 \u0026lt;ul class=\u0026#34;sidebar\u0026#34;\u0026gt; \u0026lt;?php dynamic_sidebar(\u0026#39;sidebar-1\u0026#39;); //通过id获取指定边栏信息 ?\u0026gt; \u0026lt;/ul\u0026gt; 判断边栏内是否包含小工具 is_active_sidebar() 1 2 3 4 5 \u0026lt;?php if(is_active_sidebar(\u0026#39;left-sidebar\u0026#39;)):?\u0026gt; \u0026lt;ul class=\u0026#34;sidebar\u0026#34;\u0026gt; \u0026lt;?php dynamic_sidebar(\u0026#39;left-sidebar\u0026#39;); ?\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;?php endif;?\u0026gt; 特色图像功能 开启特色图像 1 2 3 add_action(\u0026#39;after_setup_theme\u0026#39;, function () { add_theme_support(\u0026#39;post-thumbnails\u0026#39;); }); 获取特色图像 1 2 3 4 5 6 7 8 9 10 11 /** * @see get_the_post_thumbnail() * * @param string|int[] $size Default \u0026#39;post-thumbnail\u0026#39;. * 系统内置的$size有 thumbnail：缩略图; meduim：中图; large：大图; full：原图 * 如果$size的尺寸找不到，则显示full原图. * @param string|array $attr Optional. Query string or array of attributes. Default empty. */ function the_post_thumbnail( $size = \u0026#39;post-thumbnail\u0026#39;, $attr = \u0026#39;\u0026#39; ) { echo get_the_post_thumbnail( null, $size, $attr ); } 定义更多图像尺寸 1 2 3 4 5 6 7 8 9 add_action(\u0026#39;after_setup_theme\u0026#39;, function () { add_theme_support(\u0026#39;post-thumbnails\u0026#39;); //post-thumbnail尺寸默认是不存在的，可以通过代码设置 set_post_thumbnail_size(100, 100, true); //新增自定义尺寸 add_image_size(\u0026#39;category-thumbnail\u0026#39;, 50, 50); }); 常用函数 1 2 3 4 5 6 7 8 9 10 11 //获取图片说明信息 the_post_thumbnail_caption(); //判断文章是否包含特色图片 has_post_thumbnail(); //获取特色图像id get_the_post_thumbnail_id(); //获取特色图像链接 get_the_post_thumbnail_url(); 自定义栏目功能 后台设置 获取自定义栏目信息 1 2 3 4 5 6 7 8 9 10 11 /** * @param int $post_id Post ID. * @param string $key Optional. The meta key to retrieve. By default, * returns data for all keys. Default empty. * @param bool $single Optional. Whether to return a single value. * This parameter has no effect if `$key` is not specified. * Default false. */ function get_post_meta( $post_id, $key = \u0026#39;\u0026#39;, $single = false ) { return get_metadata( \u0026#39;post\u0026#39;, $post_id, $key, $single ); } 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php if( have_posts() ): ?\u0026gt; \u0026lt;?php while( have_posts() ): the_post(); ?\u0026gt; \u0026lt;div\u0026gt; \u0026lt;strong\u0026gt;⽂章相册信息（⾃定义的）：get_post_meta\u0026lt;/strong\u0026gt; \u0026lt;?php print_r( get_post_meta( get_the_ID(), \u0026#39;gallary_img\u0026#39;, false ) ); ?\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;strong\u0026gt;⽂章价格信息（⾃定义的）：get_post_meta\u0026lt;/strong\u0026gt; \u0026lt;strong\u0026gt;因为价格信息就1个值，通过第3个个参数可以直接获取到值\u0026lt;/strong\u0026gt; \u0026lt;?php print_r( get_post_meta( get_the_ID(), \u0026#39;price\u0026#39;, true ) ); ?\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;strong\u0026gt;⽂章价格信息（⾃定义的）：get_post_meta\u0026lt;/strong\u0026gt; \u0026lt;?php print_r( get_post_meta( get_the_ID(), \u0026#39;price\u0026#39; ) ); ?\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;?php endwhile; ?\u0026gt; \u0026lt;?php endif; ?\u0026gt; 通过代码设置 添加add_post_meta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * @param int $post_id Post ID. * @param string $meta_key Metadata name. * @param mixed $meta_value Metadata value. Must be serializable if non-scalar. * @param bool $unique Optional. Whether the same key should not be added. * Default false. * @return int|false Meta ID on success, false on failure. */ function add_post_meta( $post_id, $meta_key, $meta_value, $unique = false ) { // Make sure meta is added to the post, not a revision. $the_post = wp_is_post_revision( $post_id ); if ( $the_post ) { $post_id = $the_post; } return add_metadata( \u0026#39;post\u0026#39;, $post_id, $meta_key, $meta_value, $unique ); } 更新update_post_meta，不存在则新增 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * @param int $post_id Post ID. * @param string $meta_key Metadata key. * @param mixed $meta_value Metadata value. Must be serializable if non-scalar. * @param mixed $prev_value Optional. Previous value to check before updating. * If specified, only update existing metadata entries with * this value. Otherwise, update all entries. Default empty. * @return int|bool Meta ID if the key didn\u0026#39;t exist, true on successful update, * false on failure or if the value passed to the function * is the same as the one that is already in the database. */ function update_post_meta( $post_id, $meta_key, $meta_value, $prev_value = \u0026#39;\u0026#39; ) { // Make sure meta is updated for the post, not for a revision. $the_post = wp_is_post_revision( $post_id ); if ( $the_post ) { $post_id = $the_post; } return update_metadata( \u0026#39;post\u0026#39;, $post_id, $meta_key, $meta_value, $prev_value ); } 删除delete_post_meta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * @param int $post_id Post ID. * @param string $meta_key Metadata name. * @param mixed $meta_value Optional. Metadata value. If provided, * rows will only be removed that match the value. * Must be serializable if non-scalar. Default empty. * @return bool True on success, false on failure. */ function delete_post_meta( $post_id, $meta_key, $meta_value = \u0026#39;\u0026#39; ) { // Make sure meta is deleted from the post, not from a revision. $the_post = wp_is_post_revision( $post_id ); if ( $the_post ) { $post_id = $the_post; } return delete_metadata( \u0026#39;post\u0026#39;, $post_id, $meta_key, $meta_value ); } 隐藏的自定义栏目，后台无法设置 1 2 3 //下滑线开头的字段，后台不展示，用户无法设置 add_post_meta($post_id, \u0026#39;_myKey\u0026#39;, \u0026#39;隐藏的值\u0026#39;); get_post_meta($post_id, \u0026#39;_mykey\u0026#39;, true); 常用功能 设置浏览次数 定义函数 通过 隐藏的(下划线开头的key)自定义栏目实现浏览次数。functions.php中定义以下函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * 设置⽂章/⻚⾯ 浏览次数 * _wphollis_postviews是⾃定义栏⽬的名字 * @param int $post_id ⽂章的ID编号 */ function wphollis_set_postviews($post_id) { // 详情⻚才处理 if ( is_singular() \u0026amp;\u0026amp; ! empty( $post_id ) ) { $views = get_post_meta($post_id, \u0026#39;_wphollis_postviews\u0026#39;, true); $views = ! empty( $views ) ? $views : 0; $views++; update_post_meta($post_id, \u0026#39;_wphollis_postviews\u0026#39;, $views); } } /** * 获取⽂章/⻚⾯ 浏览次数 * @param int ⽂章的ID编号 * @return int 浏览次数 */ function wphollis_get_postviews( $post_id ) { if ( ! empty( $post_id ) ) { $views = get_post_meta($post_id, \u0026#39;_wphollis_postviews\u0026#39;, true); $views = ! empty( $views ) ? (int)$views : 0; return $views; } } 前台使用 （在内容详情页中添加以下代码） 1 2 3 4 5 6 7 8 \u0026lt;?php wphollis_set_postviews(get_queried_object_id());//更新文章浏览次数 ?\u0026gt; \u0026lt;?php if (have_posts()) :?\u0026gt; \u0026lt;?php while (have_posts()) : the_post(); ?\u0026gt; \u0026lt;?php the_title(); ?\u0026gt; \u0026lt;?php wphollis_get_postviews(get_the_ID());//获取文章浏览次数 ?\u0026gt; \u0026lt;?php endwhile; ?\u0026gt; \u0026lt;?php endif; ?\u0026gt; 获取当前用户访问的网页网址 在当前主题functions.php文件中定义以下函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 获取⽤⼾当前访问的⽹址 */ function wphollis_get_current_url() { global $wp, $wp_rewrite; // 获取重写规则，朴素模式规则为空 $rewrite = $wp_rewrite-\u0026gt;wp_rewrite_rules(); // ⾮朴素模式下，返回当前⽹址 if ( !empty($rewrite) ) { return home_url( $wp-\u0026gt;request ); } // 在朴素模式下，返回当前⽹址 return home_url( \u0026#39;?\u0026#39; . $wp-\u0026gt;query_string ); } 正文自动截取 在当前主题functions.php文件中定义以下函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * @params $len 要截取的字符长度 * @params $suffix 后缀标记 * */ function hollis_strim_post_content($len = 100, $suffix = \u0026#39;...\u0026#39;) { //获取正文信息，并做必要处理 $content = get_the_content(); //这里触发the_content的钩子，执行挂载该钩子的所有方法 //这里不写这个语句也可以，但是为了兼容wp的扩展性要求加上 $content = apply_filters(\u0026#39;the_content\u0026#39;, $content); $content = str_replace(\u0026#39;]]\u0026gt;\u0026#39;, \u0026#39;]]\u0026amp;gt;\u0026#39;, $content); //去除正文中的HTML标签 $content = strip_tags($content); if (mb_strlen($content) \u0026lt;= $len) { //字符数量少于要截取的长度，则展示全部 return $content; } else { return $content = mb_substr($content, 0, $len) . $suffix; } } 给嵌套评论添加回复关系信息 原理就是通过get_comment_author_link钩子，把评论者的link扩展成带回复关系的两个link\n在当前主题functions.php文件中定义以下函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * 增加谁回复谁 * 所有⽤到的钩⼦信息⸺ * apply_filters( \u0026#39;get_comment_author_link\u0026#39;, $return, $author, $comment-\u0026gt;comment_ID ); * @param string $out 未修改的评论数据，即wordpress默认提供的数据 * @param int $comment_id 评论的编号 * @return string */ function wphollis_who_resp_who($out, $author, $comment_id) { $comment = get_comment($comment_id); // 如果没有⽗级评论，则正常返回，因为没有回复关系 if ( empty($comment-\u0026gt;comment_parent) ) { return $out; } /** * 如果有⽗级评论，则添加回复关系 */ // 获取⽗（原）评论 $parent = get_comment($comment-\u0026gt;comment_parent); // 获取⽗（原）评论作者 $pauthor = get_comment_author($parent); // 构件回复关系 $pcid = \u0026#39;#comment-\u0026#39; . $parent-\u0026gt;comment_ID; $new = $out . \u0026#39; 回复 \u0026#39;. \u0026#34;\u0026lt;a href=\u0026#39;{$pcid}\u0026#39;\u0026gt;{$pauthor}\u0026lt;/a\u0026gt;\u0026#34;; // 返回修改后的评论数据 return $new; } add_filter(\u0026#39;get_comment_author_link\u0026#39;, \u0026#39;wphollis_who_resp_who\u0026#39;, 10, 3); 解决评论模板notice提示 调用comments_template()方法的时候，wp会优先查找当前主题下有没有comments.php文件，如果没有则采用wp自带的模板wp-includes/theme-compat/comments.php\n修改菜单输出结构 添加并定义⼀个⾃定义函数⽂件（名称随意）：class-my-nav-walker.php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class wphollis_Nav_Walker extends Walker_Nav_Menu { /** * 修改⼆级菜单 */ public function end_lvl( \u0026amp;$output, $depth = 0, $args = array() ) { if ( isset( $args-\u0026gt;item_spacing ) \u0026amp;\u0026amp; \u0026#39;discard\u0026#39; === $args-\u0026gt;item_spacing ) { $t = \u0026#39;\u0026#39;; $n = \u0026#39;\u0026#39;; } else { $t = \u0026#34;\\t\u0026#34;; $n = \u0026#34;\\n\u0026#34;; } $indent = str_repeat( $t, $depth ); $suffix = \u0026#39;\u0026lt;span class=\u0026#34;fa fa-angle-down\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026#39;; // 添加的按钮对应的HTML $output .= \u0026#34;$indent\u0026lt;/ul\u0026gt;{$suffix}{$n}\u0026#34;; } } 在funcitons.php中加载这个类 1 2 3 add_action(\u0026#39;after_setup_theme\u0026#39;, function () { include get_theme_file_path() . \u0026#39;/inc/class-my-nav-walker.php\u0026#39;; }); 前台页面中调用菜单 1 2 3 4 5 6 7 \u0026lt;?php wp_nav_menu([ \u0026#39;theme_location\u0026#39; =\u0026gt; \u0026#39;nav-1\u0026#39;, \u0026#39;walker\u0026#39; =\u0026gt; new wphollis_Nav_Walker() ]); ?\u0026gt; 实战案例 导入测试数据 下载好 xml的数据⽂件, 在 后台 ⼯具 \u0026mdash;-\u0026gt; 导⼊ \u0026mdash;-\u0026gt; WordPress导⼊器安装 \u0026mdash;-\u0026gt; 选择xml⽂件导⼊数\n据\n开启所需功能并引入所需的样式文件 functions.php文件中定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 add_action(\u0026#39;after_setup_theme\u0026#39;, function () { // 开启⻚⾯标题功能 add_theme_support(\u0026#39;title-tag\u0026#39;); // 开启特色图像 add_theme_support(\u0026#39;post-thumbnails\u0026#39;); // 定义导航菜单 register_nav_menus([ \u0026#39;header_menu\u0026#39; =\u0026gt; \u0026#39;顶部导航\u0026#39;, \u0026#39;footer_menu\u0026#39; =\u0026gt; \u0026#39;底部导航\u0026#39;, ]); }); // 定义边栏 add_action(\u0026#39;widgets_init\u0026#39;, function () { register_sidebar([ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;边栏1\u0026#39;, \u0026#39;id\u0026#39; =\u0026gt; \u0026#39;sidebar1\u0026#39;, \u0026#39;decsription\u0026#39; =\u0026gt; \u0026#39;边栏1\u0026#39;, ]); }); // 引入所需的样式文件 add_action(\u0026#39;wp_enqueue_scripts\u0026#39;, function () { wp_enqueue_style(\u0026#39;main-css\u0026#39;, get_theme_file_uri() . \u0026#39;/main.css\u0026#39;, [], \u0026#39;1.0\u0026#39;); wp_enqueue_script(\u0026#39;main-js\u0026#39;, get_theme_file_uri() . \u0026#39;/main.js\u0026#39;, [], \u0026#39;1.0\u0026#39;); }); 获取登录和注册的URL 注册地址 1 wp_registration_url(); 登录地址 1 wp_login_url(wphollis_get_current_url()); 获取文章作者 1 2 3 4 5 6 7 8 9 10 11 // 获取文章作者归档页。 作者名称+链接 get_the_author_posts_link(); // 获取文章作者归档页url get_author_posts_url(); // 获取作者id get_the_author_meta(\u0026#39;ID\u0026#39;); // 获取用户头像。get_avatar($id_or_email, $size); get_avatar(get_the_author_meta(\u0026#39;ID\u0026#39;), 24); 回复评论，不刷新定位到回复框 在functions.php中添加：\n1 2 3 4 5 //（是否是详情页 \u0026amp;\u0026amp; ⽂章是否开启评论 \u0026amp;\u0026amp; 后台是否开启嵌套评论） // 调取官⽅原⽣回复评论跳转函数 if(is_singular() \u0026amp;\u0026amp; comments_open() \u0026amp;\u0026amp; get_option(\u0026#39;thread_comments\u0026#39;)){ wp_enqueue_script(\u0026#39;comment-reply\u0026#39;); } 设置wp指定的class属性值 在body ⾥⾯设置class属性值 1 \u0026lt;body \u0026lt;?php body_class() ?\u0026gt; \u0026gt; 在article ⾥⾯设置class属性值 1 \u0026lt;article \u0026lt;?php post_class() ?\u0026gt; \u0026gt; 归档页标题调取以及获取文章的缩略图 1 2 3 4 5 6 \u0026lt;!-- 归档页标题 --\u0026gt; \u0026lt;header class=\u0026#34;list-header\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;span\u0026gt;\u0026lt;?php the_archivce_title(); ?\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;/header\u0026gt; 1 2 3 4 5 6 7 8 \u0026lt;!-- 获取文章缩略图 --\u0026gt; \u0026lt;a href=\u0026#34;\u0026lt;?php the_permalink() ?\u0026gt;\u0026#34;\u0026gt; \u0026lt;?php if (has_post_thumbnail()) : ?\u0026gt; \u0026lt;?php the_post_thumbnail(\u0026#39;thumbnail\u0026#39;); ?\u0026gt; \u0026lt;?php else : ?\u0026gt; \u0026lt;img src=\u0026#34;\u0026lt;?php echo get_theme_file_uri(); ?\u0026gt;/default.png\u0026#34;\u0026gt; \u0026lt;?php endif; ?\u0026gt; \u0026lt;/a\u0026gt; 首页模板文件开发 1 2 3 4 5 6 7 8 9 \u0026lt;!-- 判断置顶⽂章显⽰ is_sticky()--\u0026gt; \u0026lt;?php if(is_sticky()) :?\u0026gt; \u0026lt;span class=\u0026#34;sticky\u0026#34;\u0026gt;置顶\u0026lt;/span\u0026gt; \u0026lt;?php endif; ?\u0026gt; \u0026lt;!--调取分⻚--\u0026gt; \u0026lt;div class=\u0026#34;posts-nav\u0026#34;\u0026gt; \u0026lt;?php echo the_posts_pagination(); ?\u0026gt; \u0026lt;/div\u0026gt; ","date":"2024-03-23T02:17:45+08:00","permalink":"https://hollisho.github.io/p/wordpress%E4%B8%BB%E9%A2%98%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/","title":"Wordpress主题核心知识点梳理"},{"content":"Kafka 简介 Kafka 是一个分布式的流处理平台，最初由 LinkedIn 开发，后来成为 Apache 项目。它具有高吞吐量、可靠性和可扩展性的特点，被广泛应用于日志收集、消息系统、活动追踪、流式处理等场景。\nKafka 架构设计 Kafka 的核心架构包含以下几个关键组件：\nBroker Broker 是 Kafka 集群中的服务器节点，负责接收和处理客户端请求，存储消息数据。每个 Broker 都有一个唯一的 ID，可以独立运行。\nProducer Producer 是消息生产者，负责将消息发送到 Kafka 集群中的特定 Topic。Producer 可以选择同步或异步的方式发送消息。\nConsumer Consumer 是消息消费者，负责从 Kafka 集群中订阅并消费消息。Consumer 可以单独消费，也可以组成 Consumer Group 共同消费。\nTopic Topic 是消息的逻辑分类，每个 Topic 可以有多个 Partition。Producer 发送消息到特定的 Topic，Consumer 从特定的 Topic 消费消息。\nPartition Partition 是 Topic 的物理分区，每个 Partition 是一个有序的、不可变的消息序列。Partition 的引入使得 Kafka 可以实现水平扩展和并行处理。\nSegment Segment 是 Partition 的物理存储单元，每个 Partition 由多个 Segment 组成。当 Segment 达到一定大小或时间阈值时，会创建新的 Segment。\nLog Log 是 Kafka 中最基本的数据存储单元，每个 Partition 对应一个 Log，Log 由多个 Segment 文件组成。\nZooKeeper ZooKeeper 用于管理和协调 Kafka 集群，存储元数据信息，如 Broker 节点、Topic 配置、消费者偏移量等。（注：新版本 Kafka 正在逐步减少对 ZooKeeper 的依赖）\nKafka 副本同步方式 Kafka 提供了三种不同的副本同步方式，通过 acks 参数控制：\n1. ack=0 (半同步复制) Producer 发送消息后不等待任何确认 最高的吞吐量，但无法保证消息已被接收 可能导致消息丢失 适用于对数据一致性要求不高的场景，如日志收集 2. ack=1 (异步复制) Producer 发送消息后，等待 Leader 副本确认 不等待 Follower 副本同步完成 在 Leader 崩溃时可能丢失数据 吞吐量和可靠性的折中方案 3. ack=all/-1 (同步复制) Producer 发送消息后，等待所有 ISR 中的副本确认 最高的可靠性，但吞吐量最低 只要有一个 ISR 中的副本存活，就不会丢失数据 适用于对数据一致性要求高的场景，如金融交易 ISR 机制 (In-Sync Replicas) ISR 是与 Leader 保持同步的副本集合 AR (Assigned Replicas) = ISR (In-Sync Replicas) + OSR (Out-of-Sync Replicas) 副本滞后超过 replica.lag.time.max.ms 会被踢出 ISR 当副本重新追上 Leader 时，会被重新加入 ISR ISR 机制是 Kafka 实现高可用和数据一致性的核心 Kafka 消息发送流程 Producer 创建 ProducerRecord，指定 Topic 和消息内容 消息经过序列化器、分区器处理 分区器根据 Key 或轮询方式选择目标 Partition 消息被添加到内存中的批次 (Batch) Sender 线程定期将批次发送到对应的 Broker Broker 接收消息并写入对应 Partition 的 Leader 副本 根据 acks 配置，等待副本同步完成 返回响应给 Producer Kafka 消息存储流程 Broker 接收到消息后，将其追加到对应 Partition 的当前活跃 Segment 中 消息以追加写的方式写入磁盘，提高写入效率 消息按照 Offset 顺序存储，每条消息有唯一的 Offset 当 Segment 达到配置的大小或时间阈值，创建新的 Segment 旧的 Segment 会在配置的保留时间后被删除或压缩 Kafka 使用页缓存和零拷贝技术优化 I/O 性能 Kafka 消息消费流程 Consumer 向 Coordinator 发送 JoinGroup 请求加入消费组 Coordinator 选择一个 Consumer 作为 Leader，进行分区分配 分配结果通过 SyncGroup 请求同步给所有 Consumer Consumer 向对应的 Broker 发送 Fetch 请求获取消息 Broker 返回消息给 Consumer Consumer 处理消息并定期提交消费位移 (Offset) 位移提交可以是自动的或手动的，保存在内部 Topic __consumer_offsets 中 主从同步 Kafka 的主从同步基于 Leader-Follower 模型：\n每个 Partition 有一个 Leader 和多个 Follower 所有读写请求都由 Leader 处理 Follower 通过 Fetch 请求从 Leader 拉取消息 HW (High Watermark) 表示所有 ISR 副本都已复制的位置 LEO (Log End Offset) 表示每个副本的日志末端位置 消费者只能消费到 HW 位置的消息，保证数据一致性 当 Leader 失效时，从 ISR 中选举新的 Leader 高可用 Kafka 通过以下机制实现高可用：\n多副本机制：每个 Partition 可以配置多个副本，分布在不同的 Broker 上 Leader 选举：当 Leader 失效时，Controller 会从 ISR 中选择一个 Follower 成为新的 Leader Controller 选举：集群中的一个 Broker 会被选为 Controller，负责分区分配和故障转移 Rebalance 机制：当 Consumer 加入或离开消费组时，会触发 Rebalance，重新分配分区 自动平衡：Kafka 支持自动平衡 Leader 分区，避免单个 Broker 负载过高 消息顺序 Kafka 对消息顺序的保证：\n单个 Partition 内的消息是有序的 不同 Partition 之间的消息无法保证顺序 如果需要全局顺序，可以使用只有一个 Partition 的 Topic 如果需要按 Key 顺序，可以确保相同 Key 的消息路由到同一个 Partition 消息重复 消息重复的原因和处理：\n原因：网络问题、Broker 崩溃、Consumer 崩溃等导致重试或重新消费 Producer 端：启用幂等性 (enable.idempotence=true) 和事务功能 Consumer 端：实现幂等消费，如使用唯一标识、状态检查、分布式锁等 最佳实践：设计业务逻辑时考虑幂等性，确保多次处理同一消息不会产生副作用 消息丢失 消息丢失的场景和防止措施：\nProducer 端：\n使用 acks=all 确保所有 ISR 副本都收到消息 启用重试机制 (retries 参数) 使用回调机制确认消息发送结果 Broker 端：\n配置足够的副本数 (replication.factor\u0026gt;=3) 配置最小 ISR 数量 (min.insync.replicas\u0026gt;=2) 合理配置刷盘策略 (log.flush.* 参数) Consumer 端：\n手动提交位移，确保消息处理成功后再提交 使用事务确保消息处理和位移提交的原子性 避免长时间处理单条消息，防止会话超时 消息积压 消息积压的原因和解决方案：\n原因：\nConsumer 处理能力不足 突发流量高峰 Consumer 异常或宕机 网络问题 解决方案：\n增加 Consumer 实例和 Partition 数量 优化 Consumer 处理逻辑，提高处理效率 实现背压机制，控制生产速度 使用更高性能的硬件 临时将消息转储到其他存储，离线处理 消息延迟 Kafka 中的延迟消息实现：\nKafka 原生不支持延迟消息，但可以通过以下方式实现： 使用定时任务扫描特定 Topic 使用时间轮算法在应用层实现 创建多个 Topic 代表不同的延迟级别 使用外部组件如 Apache Pulsar 或 RocketMQ 的延迟功能 零拷贝 Kafka 使用零拷贝技术提高性能：\n传统 I/O 模型：数据在磁盘、内核空间、用户空间和网络之间多次拷贝 零拷贝技术：利用 sendfile() 系统调用，直接从磁盘到网络接口传输数据 优势： 减少数据拷贝次数 减少上下文切换 降低 CPU 使用率 提高吞吐量 应用场景：Kafka 的日志文件传输、Consumer 消费消息 Kafka 调优 Broker 调优 合理设置 num.network.threads 和 num.io.threads 优化 JVM 参数，如堆大小、GC 策略 配置适当的 log.retention.hours 和 log.segment.bytes 使用 RAID 10 磁盘阵列提高 I/O 性能 Producer 调优 增大 batch.size 和 linger.ms 提高批量发送效率 配置合适的 buffer.memory 避免内存溢出 根据场景选择合适的 compression.type 调整 max.in.flight.requests.per.connection 平衡吞吐量和顺序性 Consumer 调优 合理设置 fetch.min.bytes 和 fetch.max.wait.ms 优化 max.poll.records 控制单次拉取的消息数量 调整 max.poll.interval.ms 避免消费者被踢出消费组 实现并行处理提高消费效率 总结 Kafka 作为一个高性能、分布式的流处理平台，通过精心设计的架构和机制，实现了高吞吐量、可靠性和可扩展性。理解 Kafka 的核心概念和工作原理，对于构建高效、可靠的消息系统至关重要。\nKafka 存储结构详解 Kafka 的存储结构是其高性能的关键因素之一，它采用了分层的存储设计，从上到下依次为：Topic、Partition、Segment、Index 和 Log。\nTopic 与 Partition Topic 是消息的逻辑分类，而 Partition 是 Topic 的物理分区。每个 Topic 可以有多个 Partition，这些 Partition 分布在不同的 Broker 上，实现了数据的分布式存储和并行处理。\nPartition 的数量决定了 Topic 的并行度，增加 Partition 数量可以提高吞吐量，但也会增加系统开销和复杂性。Partition 的数量一旦设定，通常不建议减少，因为这可能导致数据丢失。\nSegment 文件 每个 Partition 由多个 Segment 文件组成，Segment 是 Kafka 存储的基本单位。当 Segment 达到一定大小（默认 1GB）或时间阈值时，会创建新的 Segment。\nSegment 文件命名规则为：[baseOffset].[index|log|timeindex]，其中 baseOffset 是该 Segment 中第一条消息的 Offset。\n每个 Segment 包含以下文件：\n.log 文件：存储实际的消息数据 .index 文件：存储消息的物理位置索引 .timeindex 文件：存储时间戳索引（Kafka 0.10.0 版本后引入） 索引机制 Kafka 使用稀疏索引来提高查找效率。索引文件中并不是每条消息都有索引项，而是每隔一定字节数（默认 4KB）的消息才会创建一个索引项。\n索引项包含两个部分：\n相对 Offset：消息的 Offset 相对于 Segment 基准 Offset 的值 物理位置：消息在 .log 文件中的物理位置（字节偏移量） 当需要查找特定 Offset 的消息时，Kafka 首先找到该 Offset 所在的 Segment，然后在索引文件中找到小于等于目标 Offset 的最大索引项，从该位置开始顺序扫描 .log 文件，直到找到目标消息。\n日志清理 Kafka 提供了两种日志清理策略：\n基于时间的删除：通过 log.retention.hours 配置，删除超过保留时间的旧 Segment 基于大小的删除：通过 log.retention.bytes 配置，当 Partition 大小超过阈值时，删除最旧的 Segment 日志压缩：通过 log.cleanup.policy=compact 配置，保留每个 Key 的最新值，删除旧值 日志压缩特别适用于需要保留最新状态的场景，如配置更新、状态变更等。\n文件系统与页缓存 Kafka 直接使用文件系统存储数据，而不是使用数据库。它充分利用操作系统的页缓存（Page Cache）来提高 I/O 性能：\n写入操作：追加写入文件系统，由操作系统负责刷盘 读取操作：优先从页缓存读取，命中率高时可以避免磁盘 I/O 这种设计使得 Kafka 在处理大量数据时仍能保持高性能，同时简化了系统架构。\n存储格式 Kafka 消息的存储格式经过精心设计，包含以下字段：\n8 字节 Offset 4 字节消息大小 4 字节 CRC32 校验和 1 字节魔数（Magic Byte） 1 字节属性（压缩类型等） 4 字节 Key 长度（-1 表示没有 Key） Key 数据（如果存在） 4 字节 Value 长度 Value 数据（实际消息内容） 这种格式设计既保证了数据完整性，又兼顾了存储效率。\n批量写入与压缩 Kafka 支持消息批量写入和压缩，以提高存储效率和网络传输效率：\n批量写入：多条消息组成一个批次（Batch），一次性写入磁盘 压缩：支持 GZIP、Snappy、LZ4、ZStandard 等压缩算法 端到端压缩：Producer 压缩，Broker 保持压缩状态存储，Consumer 解压 压缩率取决于消息内容的特性，对于文本类数据，通常可以达到 3-5 倍的压缩比。\n存储优化最佳实践 合理设置 Partition 数量：\n考虑并行度需求和资源限制 一般建议每个 Broker 的 Partition 数不超过 2000-4000 优化磁盘配置：\n使用 SSD 提高随机读写性能 使用 RAID 10 而非 RAID 5/6 分离操作系统和数据目录 调整 Segment 大小：\n较小的 Segment 有利于及时清理过期数据 较大的 Segment 减少文件数量，降低管理开销 合理配置保留策略：\n根据业务需求设置 log.retention.hours 和 log.retention.bytes 对不同 Topic 设置不同的保留策略 监控磁盘使用率：\n保持足够的磁盘空间（至少 20% 空闲） 设置磁盘使用率告警 ","date":"2024-01-10T11:34:49+08:00","permalink":"https://hollisho.github.io/p/kafka%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/","title":"Kafka知识整理"}]