[{"content":"微信支付签名（基于对称加密） 优点 性能高 对称加密算法（如MD5、HMAC-SHA256）计算速度快，适合高并发场景。 微信支付每天处理海量交易，性能是关键考量。 实现简单 只需要一个共享的API密钥（商户和微信支付平台都知道），实现和部署较为简单。 不需要管理复杂的公钥和私钥对。 适合短周期请求 微信支付的请求生命周期短，通常只需在请求和响应的短时间内保证数据完整性，对称加密足够满足需求。 兼容性强 对称加密算法广泛支持，各种编程语言和平台都能轻松实现。 缺点 密钥管理风险 API密钥需要共享，存在泄露风险。如果密钥泄露，攻击者可以伪造请求。 需要定期更换密钥以降低风险。 不支持不可否认性 对称加密无法证明请求的唯一来源，因为双方共享同一个密钥。 如果发生纠纷，无法通过签名证明请求是由某一方发起的。 安全性较低 相比非对称加密，对称加密的安全性较弱，尤其是在密钥泄露的情况下。 电子签名（基于非对称加密） 优点 安全性高 非对称加密使用公钥和私钥对，私钥无需共享，安全性更高。 即使公钥泄露，也无法伪造签名。 不可否认性 签名是用私钥生成的，只有持有私钥的一方才能生成签名，因此可以证明请求的唯一来源。 在法律和审计场景中非常重要。 数据完整性 电子签名不仅可以验证数据完整性，还可以验证数据的真实性。 缺点 性能低 非对称加密算法（如RSA、ECC）计算复杂度高，速度较慢。 在高并发场景下（如微信支付），性能可能成为瓶颈。 实现复杂 需要管理公钥和私钥对，密钥分发和管理复杂度高。 需要额外的基础设施（如证书颁发机构CA）来支持公钥的分发和验证。 不适合短周期请求 非对称加密更适合长期有效的数据签名（如合同、证书），而微信支付的请求生命周期短，使用非对称加密显得过于复杂。 微信支付为什么选择对称加密签名？ 业务场景需求 微信支付的核心需求是数据完整性和身份认证，而不是不可否认性。 支付请求的生命周期短，通常只需在短时间内保证数据安全。 性能优先 微信支付每天处理数十亿笔交易，性能是关键。对称加密的计算速度远快于非对称加密。 实现简单 对称加密的实现和部署更简单，适合快速迭代和扩展。 风险可控 虽然对称加密的密钥管理存在风险，但微信支付通过其他安全措施（如HTTPS、IP白名单、风控系统）来降低风险。 总结 特性 微信支付签名（对称加密） 电子签名（非对称加密） 性能 高 低 实现复杂度 简单 复杂 安全性 较低（依赖密钥管理） 高 不可否认性 不支持 支持 适用场景 高并发、短周期请求（如支付） 长期有效数据（如合同、证书） 微信支付选择对称加密签名是为了在性能、实现复杂度、业务需求之间找到最佳平衡。虽然对称加密的安全性较低，但通过其他安全措施可以弥补这一不足。而电子签名更适合对安全性和不可否认性要求更高的场景（如法律文件、合同签署）。\n","date":"2025-03-17T14:41:07+08:00","permalink":"https://hollisho.github.io/p/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E7%AD%BE%E5%90%8D%E5%9F%BA%E4%BA%8E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86vs%E7%94%B5%E5%AD%90%E7%AD%BE%E5%90%8D%E5%9F%BA%E4%BA%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/","title":"微信支付签名（基于对称加密）vs电子签名（基于非对称加密）"},{"content":"PHP Helpers PHP Helpers 是一个简单易用的 PHP 工具集合，它提供了许多常用的辅助函数，可以帮助你更快速、更方便地完成 PHP 开发工作。无论你是 PHP 新手还是有经验的开发者，这个工具包都能让你的编码更加高效。\n安装 基本使用方法 1. 在项目中引入 安装完成后，你需要在你的 PHP 文件中引入 Composer 的自动加载文件：\n1 require_once \u0026#39;vendor/autoload.php\u0026#39;; 2. 使用辅助函数 PHP Helpers 提供了多种辅助函数，你可以直接调用它们：\n1 2 3 4 5 // 例如使用数组辅助函数 $result = \\Hollisho\\Helpers\\ArrayHelper::get($array, \u0026#39;user.name\u0026#39;, \u0026#39;默认值\u0026#39;); // 例如使用字符串辅助函数 $slug = \\Hollisho\\Helpers\\StringHelper::slug(\u0026#39;Hello World\u0026#39;); 常用功能示例 数组操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 从多维数组中安全获取值 $user = [ \u0026#39;profile\u0026#39; =\u0026gt; [ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;张三\u0026#39;, \u0026#39;age\u0026#39; =\u0026gt; 25 ] ]; // 获取用户名 $name = \\Hollisho\\Helpers\\ArrayHelper::get($user, \u0026#39;profile.name\u0026#39;); echo $name; // 输出: 张三 // 如果键不存在，返回默认值 $address = \\Hollisho\\Helpers\\ArrayHelper::get($user, \u0026#39;profile.address\u0026#39;, \u0026#39;未设置\u0026#39;); echo $address; // 输出: 未设置 1 2 3 4 5 6 7 8 9 10 ### 字符串处理 ```php // 生成URL友好的字符串 $slug = \\Hollisho\\Helpers\\StringHelper::slug(\u0026#39;你好 世界\u0026#39;); echo $slug; // 输出: ni-hao-shi-jie 或类似格式 // 随机字符串生成 $random = \\Hollisho\\Helpers\\StringHelper::random(8); echo $random; // 输出: 类似 a1b2c3d4 的8位随机字符串 日期时间处理 1 2 3 4 5 6 7 // 格式化日期 $formatted = \\Hollisho\\Helpers\\DateHelper::format(\u0026#39;2023-01-01\u0026#39;, \u0026#39;Y年m月d日\u0026#39;); echo $formatted; // 输出: 2023年01月01日 // 获取两个日期之间的天数 $days = \\Hollisho\\Helpers\\DateHelper::diffInDays(\u0026#39;2023-01-01\u0026#39;, \u0026#39;2023-01-10\u0026#39;); echo $days; // 输出: 9 环境变量功能 如果你需要使用环境变量功能（EnvHelper），需要额外安装 vlucas/phpdotenv 扩展：\n1 composer require vlucas/phpdotenv:^5.6 安装后，你可以这样使用：\n1 2 3 4 5 6 // 加载 .env 文件 \\Hollisho\\Helpers\\EnvHelper::load(\u0026#39;/path/to/your/project\u0026#39;); // 获取环境变量 $dbName = \\Hollisho\\Helpers\\EnvHelper::get(\u0026#39;DB_NAME\u0026#39;, \u0026#39;default_db\u0026#39;); echo $dbName; 如何测试 创建一个测试文件，例如 test.php ： 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php // 引入自动加载文件 require_once \u0026#39;vendor/autoload.php\u0026#39;; // 测试数组辅助函数 $array = [\u0026#39;user\u0026#39; =\u0026gt; [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;李四\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;lisi@example.com\u0026#39;]]; $name = \\Hollisho\\Helpers\\ArrayHelper::get($array, \u0026#39;user.name\u0026#39;); echo \u0026#34;用户名: \u0026#34; . $name . \u0026#34;\\n\u0026#34;; // 测试字符串辅助函数 $random = \\Hollisho\\Helpers\\StringHelper::random(10); echo \u0026#34;随机字符串: \u0026#34; . $random . \u0026#34;\\n\u0026#34;; ","date":"2025-03-17T13:49:36+08:00","permalink":"https://hollisho.github.io/p/php%E5%B8%B8%E7%94%A8%E5%8A%A9%E6%89%8B%E7%B1%BB%E5%BA%93php-helpers-%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","title":"PHP常用助手类库PHP Helpers 简介和使用方法"},{"content":"简介 hollisho/http-client 是一个功能强大且易于使用的PHP HTTP客户端库，旨在简化REST API的调用和集成。它提供了灵活的配置选项、中间件支持和基于注解的API定义，让开发者能够更高效地处理HTTP请求。\n主要特性 🚀 支持多种HTTP方法（GET, POST, PUT, DELETE等） 🔧 可扩展的中间件系统 🎯 基于注解的API定义 🛡️ 内置认证支持（Basic Auth） 📦 自动处理JSON请求/响应 ⚡ 兼容PHP 7.x 和 PHP 8.0+ 快速开始 安装 1 composer require hollisho/http-client 基本使用 1 2 3 4 use hollisho\\httpclient\\BaseClient; $httpClient = new BaseClient(\u0026#39;https://api.example.com\u0026#39;); $response = $httpClient-\u0026gt;httpGet(\u0026#39;/users\u0026#39;); 使用注解定义API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * @BaseUrl(host=\u0026#34;https://api.example.com\u0026#34;) */ interface UserService { /** * @Action( * method=@Get, * endpoint=@Endpoint(uri=\u0026#34;/users/{id}\u0026#34;) * ) */ public function getUser($id); } $client = FeignClientFactory::create(UserService::class); $user = $client-\u0026gt;getUser(123); 为什么选择 hollisho/http-client？ 简化开发 ：通过注解自动生成API客户端，减少样板代码 灵活扩展 ：支持自定义中间件，轻松添加日志、缓存等功能 现代PHP支持 ：全面支持PHP 8.0+的新特性 文档完善 ：提供详细的文档和示例代码 活跃维护 ：持续更新和维护，及时修复问题 获取更多信息 GitHub仓库 完整文档 示例代码 立即体验 hollisho/http-client ，让您的PHP HTTP请求处理更加高效便捷！ ","date":"2024-11-11T14:41:07+08:00","permalink":"https://hollisho.github.io/p/%E9%AB%98%E6%95%88php-http%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%93-hollisho/http-client/","title":"高效PHP HTTP客户端库 - hollisho/http-client"},{"content":"Shopify App开发知识整理 修订记录 日期 版本 说明 作者 2024-07-08 v1.0.0 Hollis 前期准备 相关网址 Shopify官网（https://www.shopify.com/）\nShopify开发文档（https://shopify.dev/）\nShopify合作伙伴（https://www.shopify.com/partners）\n相关概念 Partner （合作伙伴）\nShopify 开发者账号，用于开发App、Theme、Extension等 App （应用）\n扩展店铺的功能，可以发布到应用市场 Theme (主题)\n设计店铺的样式，可以发布到主题市场 Custom storefront （自定义店铺）\n商店 在合作伙伴后台添加开发商城，跟着设置指南完成商店设置\nShopify Cli 本地开发环境 安装 Node.js 20.15+ 安装Node.js包管理器 npm、Yarn 或 pnpm 安装 Ruby 2.7+ 安装 Git 2.44+ 安装Shopify Cli 1 npm install -g @shopify/cli@latest 具体安装依赖参考官方文档：https://shopify.dev/docs/api/shopify-cli\n应用 商店后台应用 您可以构建一个应用程序来为 Shopify 商店添加功能并扩展商家体验，或者为客户创造独特的购买体验。您还可以将 Shopify 商店数据提取到您的应用程序、平台或集成中。\n为了根据他们的特定需求定制体验，商家使用 Shopify 应用来帮助建立他们的业务，与外部服务集成，并向他们的 Shopify 后台添加功能。 官方文档：https://shopify.dev/docs/apps/build/scaffold-app\n创建新应用 1 shopify app init 本地运行应用 1 2 cd ho-app #进入应用目录 npm run dev #运行应用 通过控制台输出的Preview URL，查看App 商店前台应用 商店前台应用也叫：主题应用扩展Extension（应用程序块、应用程序嵌入块）\n主题应用程序扩展为您的应用程序提供了两种扩展在线商店主题的集成类型：应用程序块和应用程序嵌入块。您提交到 Shopify 应用商店的每个新应用都需要使用主题应用扩展来与在线商店主题集成。\n主题应用程序扩展允许商家轻松地将动态元素添加到他们的主题中，而无需与 Liquid 模板或代码进行交互。例如，动态元素可以包括产品评论、价格、评级或产品的交互式 3D 模型。\n优点\n主题应用程序扩展会自动在主题编辑器中公开您的应用程序。您可以利用编辑器的可视化编辑功能，而无需在您的应用程序中复制它们。 您可以同时将您的应用程序部署到使用它的所有在线商店。您还可以访问Shopify CDN 上的应用程序版本控制和资产托管的生命周期管理。 一组集成逻辑和指令适用于所有主题。 商家不需要手动编辑他们的主题代码。 该部分功能还未深入研究，构建步骤略。详情参考官方文档：https://shopify.dev/docs/apps/build/online-store\n主题 创建主题 1 shopify theme init 运行主题 1 2 3 cd ho-theme # 进入主题目录 # 运行shopify theme dev --store {store}（store为开发商店的名称）。 shopify theme dev --store quickstart-c1709595 运行成功之后，通过http://127.0.0.1:9292/访问主题\nAdmin API App需要获取shopify的信息如产品、订单、客户信息等，需要通过Admin API获取。\n还有App的授权和鉴权都是通过Admin API方式。\nAdmin API分为GraphQL Admin API、REST Admin API。\nGraphQL Admin API官方文档：https://shopify.dev/docs/api/admin-graphql\nREST Admin API官方文档：https://shopify.dev/docs/api/admin-rest\n特别说明：本报告中案例采用REST Admin API方式\nApp授权和鉴权 Shopify中有两种Token，分别是Session Token会话令牌和Access Token访问令牌。\n会话令牌用于身份验证，不能替代授权。详细了解身份验证和授权之间的区别。\n与 API 访问令牌不同，会话令牌不能用于向 Shopify API 发出经过身份验证的请求。API 访问令牌可用于从应用的后端向 Shopify 发送请求，以便从用户的商店中获取特定数据。\n例如，要向GraphQL Admin API发出经过身份验证的请求，您的应用必须存储其在 OAuth 流程中收到的访问令牌。相比之下，会话令牌由您的应用的后端用来验证来自您的应用前端的嵌入式请求。\n下图显示了使用会话令牌和 API 访问令牌的身份验证过程：\n官方文档：https://shopify.dev/docs/apps/build/authentication-authorization/session-tokens\n总结：Session Token是App 前端和后端交互的凭证；Access Token是App 后端和Shopify交互的凭证。\nOAuth授权 流程图 Access Token Shopify 的 Access Token 分为两种类型：在线 和 离线\nOnline Access Token 使用在线访问模式创建的访问令牌是临时的，并且一定会在一段时间后过期。访问令牌过期后，Shopify 会返回401 Unauthorized响应代码。\n用户可以随时撤销对您应用的访问权限，而不会影响其他用户访问令牌的有效性。当用户退出 Shopify 管理平台时，在同一网络会话期间创建的所有在线模式访问令牌都将被撤销。\nOffline Access Token 使用离线访问模式创建的访问令牌是永久性的。仅当从商店卸载应用程序时，它们才会被撤销。\n多次授权应用进行离线访问时，每次都会返回相同的访问令牌。获得商店的离线访问权限后，只有在卸载应用或需要其他访问范围时才需要重新授权应用。\n","date":"2024-07-08T10:10:47+08:00","permalink":"https://hollisho.github.io/p/shopify-app%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/","title":"Shopify App开发知识整理"},{"content":"内容类型和分类方式 Debug Bar插件 Queries WP Query Object Cache Post Types Post Type 内容类型 Taxonomy 分类方式 category 分类目录 post_tag 标签 Debug Bar Taxonomy插件可以查看所有分类方式 最小主题 style.css 必填字段: Theme Name、Author、Description、Version、License、License URI、Text Domain\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* Theme Name: Mini Theme Theme URI: 主题的详细介绍的网址，仅在官方主题库中才会用到 Author: Hollis Author URI: http://www.1024plus.com Description: 最小主题 Version: 1.0.0 License: 主题的版权信息 License URI: 版权详情网址 Text Domain: 国际化相关 Tags: 标签，方便用于在官方主题库中筛选 Domain Paths: 语言包路径 */ index.php 详情页模板层级 文章详情页 1 2 3 4 5 $custom.php single-post.php single.php singular.php index.php 附件详情页 wp_posts表中post_mime_type记录了attachment的mimetype\n如：image/png，其中mimetype是image，subtype是png\n上传附件可能有大小限制，可以修改php.ini中的post_max_size\n1 2 3 4 5 6 7 $mimetype-$subtype.php $subtype.php $mimetype.php attachment.php single.php singular.php index.php 自定义内容类型详情页 1 2 3 4 5 6 $custom.php single-$posttype-$slug.php single-$posttype.php single.php singular.php index.php 页面详情页 Custom Template 采用了自定义模板 1 $custom.php 如果页面对应的自定义模板被删除了，但是数据中的对应关系还在，则按以下规则加载模板\n1 2 3 page.php singular.php index.php Default Template 采用了默认模板 1 2 3 4 5 page-$slug.php page-$id.php page.php singular.php index.php 自定义模板文件 Template Post Type 可以为空，默认只支持page\n1 2 3 4 5 6 7 \u0026lt;?php /* Template Name: 自定义模板 Template Post Type: post,page,product */ ?\u0026gt; 分类目录归档页 Category Archice 1 2 3 4 5 category-$slug.php category-$id.php category.php archive.php index.php Tag Archive 1 2 3 4 5 tag-$slug.php tag-$id.php tag.php archive.php index.php Author Archive 1 2 3 4 5 author-$nicename.php author-$id.php author.php archive.php index.php Date Archive (Year Archive、Month Archive、Day Archive) 可以通过小工具，进入到日期归档页\n1 2 3 date.php archive.php index.php 自定义内容归档页(custom post type) 1 2 3 archive-$posttype.php archive.php index.php 自定义分类方式归档页(custom taxonomy) 如：自定义产品分类product_cat，其中有phone、pc两个分类项目，则$taxonomy为product_cat、$term为phone和pc\n1 2 3 4 5 taxonomy-$taxonomy-$term.php taxonomy-$taxonomy.php taxonomy.php archive.php index.php 站点首页模板层级 Posts show on front（默认设置） 1 2 3 front-page.php home.php index.php Page show on front（一个静态页面） 1 2 front-page.php 后面的模板层级和页面详情页一致 Blog Post Index Page(指定为文章页的页面) 1 2 home.php index.php 404错误页、搜索结果页、被嵌入内容页 404错误页 1 2 404.php index.php 搜索结果页 1 2 search.php index.php 归档页默认查询结果 分类目录归档页 queried_object (WP_Term) 分类目录信息 - 日期分类归档页没有queried_object字段 queried_object_id 分类目录id posts 归档页的文章信息数组 post (WP_Post) 当前文章信息 is_archive = 1 归档页 is_category = 1 分类目录归档页 详情页默认查询结果 文章详情页 queried_object 文章信息 queried_object_id 文章id posts 数组里面只有一个文章信息 post 当前文章信息 is_single = 1 内容详情页 is_singular = 1 详情页 首页和其他页面默认查询结果 首页（默认） posts 最新发布的文章信息数组 post 当前文章信息 is_home = 1 首页（设置了自定义页面） posts 自定义页面的信息，数组只有一个元素 post 自定义页面的信息 queried_object 自定义页面的信息 queried_object_id 自定义页面id is_page = 1 is_singular = 1 详情页 Blog文章索引页（就是在阅读设置中，文章页指定了自定义页面） queried_object 自定义页面的信息 queried_object_id 自定义页面id posts 最新发布的文章信息数组 post 当前文章信息 is_home = 1 is_posts_page = 1 搜索结果页 posts 搜索结果的所有文章信息数组 post 当前文章信息 is_search = 1 404错误页 is_404 = 1 获取文章各种数据的模板标签 获取内容并输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //文章ID the_ID(); //文章标题 the_title(); //文章内容 the_content(); //文章摘要。如果没有设置摘要，会自动截取一部分内容作为摘要 the_excerpt(); //获取作者信息 the_author(); //获取文章的网址 the_permalink(); //发布时间。 //时间格式可以在设置-\u0026gt;常规中设置 //也可以指定格式the_time(\u0026#39;Y-m-d H:i:s\u0026#39;); the_time(); 获取内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //文章ID get_the_ID(); //文章标题 get_the_title(); //文章内容 get_the_content(); //文章摘要。如果没有设置摘要，会自动截取一部分内容作为摘要 get_the_excerpt(); //获取作者信息 get_the_author(); //作者归档页超链接。用户名+超链接 get_the_author_link(); //获取文章别名。自带了urlencode。使用的时候需要urldecode global $post; $post-\u0026gt;post_name; //获取文章的网址 get_the_permalink(); //发布时间。 //时间格式可以在设置-\u0026gt;常规中设置 //也可以指定格式get_the_time(\u0026#39;Y-m-d H:i:s\u0026#39;); get_the_time(); //获取文章评论数量 get_comments_number(); 获取文章所属的分类目录信息 the_category 获取内容并输出 get_the_category_list 获取内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * @param string $separator 默认以⽆序列表输出分类链接，当⽂章指定了多个分类时，提供⼀个字符⽤于分隔这些分类链接。 * @param string $parents \u0026#39;\u0026#39;：不显示父类信息； \u0026#39;multiple\u0026#39;：显示父类信息，分开显示(有各自的超链接)； \u0026#39;single\u0026#39;：显示父类信息，与子类合并显示(公用一个超链接) * @param int $post_id 在have_posts() 循环中使用时，不要传值，否则需要传入指定post_id * * 例子: * the_category(\u0026#39;,\u0026#39;, \u0026#39;multiple\u0026#39;); * 输出：\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;体育\u0026lt;/a\u0026gt;,\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;篮球\u0026lt;/a\u0026gt; * the_category(\u0026#39;,\u0026#39;, \u0026#39;single\u0026#39;); * 输出：\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;体育,篮球\u0026lt;/a\u0026gt; * */ function the_category( $separator = \u0026#39;\u0026#39;, $parents = \u0026#39;\u0026#39;, $post_id = false ) { echo get_the_category_list( $separator, $parents, $post_id ); } get_the_category（纯数据，不带html标签） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * WP_Term Object * * term_id 分类ID * name 分类名称 * slug 分类别名 * description 分类描述 * taxonomy 分类项目的分类方式 category * ...... */ $categorys = get_the_category(); foreach ($categorys as $category) { \u0026lt;p\u0026gt;编号：\u0026lt;?php echo $category-\u0026gt;term_id; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;名称：\u0026lt;?php echo $category-\u0026gt;name; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;别名：\u0026lt;?php echo $category-\u0026gt;slug; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;描述：\u0026lt;?php echo $category-\u0026gt;description; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;⽹址：\u0026lt;?php echo get_category_link($category); ?\u0026gt;\u0026lt;/p\u0026gt; } 获取文章所属标签信息 the_tags 获取标签并输出 get_the_tag_list 获取标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * @param string $before 标签链接前的内容 * @param string $sep 多个标签之间的分隔符，默认为\u0026#39;,\u0026#39; * @param string $after 标签链接后的内容 */ function the_tags( $before = null, $sep = \u0026#39;, \u0026#39;, $after = \u0026#39;\u0026#39; ) { if ( null === $before ) { $before = __( \u0026#39;Tags: \u0026#39; ); } $the_tags = get_the_tag_list( $before, $sep, $after ); if ( ! is_wp_error( $the_tags ) ) { echo $the_tags; } } /** * $post_id 文章id */ function get_the_tag_list( $before = \u0026#39;\u0026#39;, $sep = \u0026#39;\u0026#39;, $after = \u0026#39;\u0026#39;, $post_id = 0 ) get_the_tags（纯数据，不带html标签） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * WP_Term Object * * term_id 分类ID * name 分类名称 * slug 分类别名 * description 分类描述 * taxonomy 分类项目的分类方式 post_tag * ...... */ $posttags = get_the_tags(); if ($posttags) foreach($posttags as $tag) { echo \u0026#39;标签ID：\u0026#39; . $tag-\u0026gt;term_id; echo \u0026#39;\u0026lt;br /\u0026gt;标签名称：\u0026#39; . $tag-\u0026gt;name; echo \u0026#39;\u0026lt;br /\u0026gt;标签描述：\u0026#39; . $tag-\u0026gt;description; echo \u0026#39;\u0026lt;br /\u0026gt;标签网址：\u0026#39; . get_tag_link($tag); } 分类归档页中调用和显示数据 Category Archive 分类目录归档页 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //获取分类目录信息 $category = get_queried_object(); \u0026lt;p\u0026gt;编号：\u0026lt;?php echo $category-\u0026gt;term_id; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;名称：\u0026lt;?php echo $category-\u0026gt;name; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;别名：\u0026lt;?php echo $category-\u0026gt;slug; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;描述：\u0026lt;?php echo $category-\u0026gt;description; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;⽹址：\u0026lt;?php echo get_category_link($category); ?\u0026gt;\u0026lt;/p\u0026gt; //获取分类目录下面的文章信息 \u0026lt;?php if( have_posts() ): ?\u0026gt; \u0026lt;?php while( have_posts() ): the_post(); ?\u0026gt; \u0026lt;?php the_author(); //作者名称 ?\u0026gt; \u0026lt;?php the_title(); //标题 ?\u0026gt; \u0026lt;?php the_content(); //正文 ?\u0026gt; \u0026lt;?php echo get_comments_number(); //评论数量 ?\u0026gt; \u0026lt;?php endwhile; ?\u0026gt; \u0026lt;?php endif; ?\u0026gt; Tag Archive 标签归档页 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //获取标签信息 $tag = get_queried_object(); \u0026lt;p\u0026gt;编号：\u0026lt;?php echo $tag-\u0026gt;term_id; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;名称：\u0026lt;?php echo $tag-\u0026gt;name; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;别名：\u0026lt;?php echo $tag-\u0026gt;slug; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;描述：\u0026lt;?php echo $tag-\u0026gt;description; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;⽹址：\u0026lt;?php echo get_tag_link($tag); ?\u0026gt;\u0026lt;/p\u0026gt; //获取标签目录下面的文章信息 \u0026lt;?php if( have_posts() ): ?\u0026gt; \u0026lt;?php while( have_posts() ): the_post(); ?\u0026gt; \u0026lt;?php the_author(); //作者名称 ?\u0026gt; \u0026lt;?php the_title(); //标题 ?\u0026gt; \u0026lt;?php the_content(); //正文 ?\u0026gt; \u0026lt;?php echo get_comments_number(); //评论数量 ?\u0026gt; \u0026lt;?php endwhile; ?\u0026gt; \u0026lt;?php endif; ?\u0026gt; Author Archive 作者归档页 1 2 3 4 5 6 7 8 9 //获取作者信息 $author = get_queried_object(); \u0026lt;p\u0026gt;作者用户名：\u0026lt;?php echo $author-\u0026gt;user_login; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;作者ID：\u0026lt;?php echo $author-\u0026gt;ID; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;作者邮箱：\u0026lt;?php echo $author-\u0026gt;user_email; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;作者显示名：\u0026lt;?php echo $author-\u0026gt;user_display; ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;作者归档页网址：\u0026lt;?php echo get_the_author_posts_link(); ?\u0026gt;\u0026lt;/p\u0026gt; //获取文章信息同上 Date Archive 日期归档页 1 2 3 4 5 6 7 //日期归档页无法获取get_queried_object //获取日期信息 echo get_the_date(); //可以自定义日期格式 echo get_the_date(\u0026#39;Y-d-m\u0026#39;); //获取文章信息同上 通用获取分类title 1 2 3 4 //直接使用 the_archive_title(); //或者 echo get_the_archive_title(); 搜索结果归档页 1 2 3 4 5 //日期归档页无法获取get_queried_object //获取搜索结果页搜索关键字 $key = get_search_query(); //获取文章信息同上 模板标签所在的文件 模板标签所在的文件，都有一个相同的后缀*-template.php，用于区分模板文件和其他文件。\n总共有9个模板文件：\n1 2 3 4 5 6 7 8 9 wp-includes/general-template.php wp-includes/author-template.php wp-includes/bookmark-template.php wp-includes/category-template.php wp-includes/comment-template.php wp-includes/link-template.php wp-includes/post-template.php wp-includes/post-thumbnail-template.php wp-includes/nav-menu-template.php 条件标签使用举例 1 2 3 4 5 6 7 8 9 \u0026lt;?php if (is_year()) { echo get_the_date(\u0026#39;Y\u0026#39;); } elseif (is_month()) { echo get_the_date(\u0026#39;Y-m\u0026#39;); } elseif (is_day()) { echo get_the_date(\u0026#39;Y-m-d\u0026#39;); } ?\u0026gt; 首页相关条件标签 is_home is_front_page 如果首页采用了默认页面，则：\n1 2 is_home: true is_front_page: true 如果首页设置了指定页面，则：\n1 2 is_home: false is_front_page: true 获取其他信息 获取站点信息 关键函数 1 2 3 4 5 6 7 /** * @see get_bloginfo() For possible `$show` values * @param string $show Optional. Site information to display. Default empty. */ function bloginfo( $show = \u0026#39;\u0026#39; ) { echo get_bloginfo( $show, \u0026#39;display\u0026#39; ); } 通用信息 1 2 3 4 5 6 7 8 9 10 11 //站点标题 get_bloginfo(\u0026#39;name\u0026#39;); get_bloginfo(\u0026#39;blogname\u0026#39;); //站点描述 get_bloginfo(\u0026#39;description\u0026#39;); //站点首页网址，等同于site_url() get_bloginfo(\u0026#39;wpurl\u0026#39;); //站点首页网址，等同于home_url() get_bloginfo(\u0026#39;url\u0026#39;); //站点管理员邮箱 get_bloginfo(\u0026#39;admin_email\u0026#39;); 评论信息 1 2 3 4 5 6 \u0026lt;?php if (comments_open() || get_commments_number()) { //如果文章允许评论被关闭，则只显示历史评论列表，不显示评论发表框 comments_template(); } ?\u0026gt; 主题路径及url信息 1 2 3 4 //获取当前主题所在目录的网址 get_theme_file_uri() //获取当前主题所在目录的绝对路径 get_theme_file_path() 钩子机制 动作钩子 1 add_action(\u0026#39;hook_name\u0026#39;, \u0026#39;your_func\u0026#39;); 过滤器钩子 1 add_filter(\u0026#39;hook_name\u0026#39;, \u0026#39;your_func\u0026#39;); 传统引入css和js文件的方式 内联 1 \u0026lt;div style=\u0026#34;width: 65px;height: 20px;border: 1px solid;\u0026#34;\u0026gt;测试元素\u0026lt;/div\u0026gt; 页联 1 2 3 4 5 6 7 8 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; div { width: 65px; height: 20px; border: 1px solid; background: greenyellow; } \u0026lt;/style\u0026gt; 外联 1 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;*.css\u0026#34; /\u0026gt; 推荐的引入css和js文件的方式 引入css文件 1 2 3 4 5 6 7 8 9 /** * 引入css文件 * @param string $handle Name of the stylesheet. Should be unique. * @param string $src * @param string[] $deps * @param string|bool|null $ver * @param string $media */ function wp_enqueue_style( $handle, $src = \u0026#39;\u0026#39;, $deps = array(), $ver = false, $media = \u0026#39;all\u0026#39; ) 引入js文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 引入js文件 wp 6.3.0版本之后，$in_footer参数改成了$args * @since 6.3.0 The $in_footer parameter of type boolean was overloaded to be an $args parameter of type array. * @param string $handle Name of the script. Should be unique. * @param string $src Default empty. * @param string[] $deps * @param string|bool|null $ver * @param array|bool $args { * Optional. An array of additional script loading strategies. Default empty array. * Otherwise, it may be a boolean in which case it determines whether the script is printed in the footer. Default false. * * @type string $strategy Optional. If provided, may be either \u0026#39;defer\u0026#39; or \u0026#39;async\u0026#39;. * @type bool $in_footer Optional. Whether to print the script in the footer. Default \u0026#39;false\u0026#39;. * } */ function wp_enqueue_script( $handle, $src = \u0026#39;\u0026#39;, $deps = array(), $ver = false, $args = array() ) 使用案例 1 2 3 4 add_action(\u0026#39;wp_enqueue_scripts\u0026#39;, function () { wp_enqueue_style(\u0026#39;common-style\u0026#39;, get_theme_file_uri() . \u0026#39;/css/commom.css\u0026#39;); wp_enqueue_script(\u0026#39;commmon-js\u0026#39;, get_theme_file_uri() . \u0026#39;/js/common.js\u0026#39;, array(), \u0026#39;\u0026#39;, true); }) 模板文件拆分和引入 传统的引入方式 1 2 3 include \u0026#39;template-part.php\u0026#39;; //or require \u0026#39;template-part.php\u0026#39;; wp推荐方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //加载任意模板文件 get_template_part(\u0026#39;template-part\u0026#39;); //加载主题中header.php or header-$name.php get_header($name = \u0026#39;\u0026#39;) //加载主题中footer.php or footer-$name.php get_footer($name = \u0026#39;\u0026#39;) //加载主题中sidebar.php or sidebar-$name.php get_sidebar($name = \u0026#39;\u0026#39;) 分页导航 内容分页 1 2 3 //1.手动插入分页符 //2.通过wp_link_pages()显示页码 wp_link_pages(); 关联分页 获取上一篇文章链接 1 2 3 4 5 6 7 8 9 10 11 12 /** * @see get_previous_post_link() * * @param string $format Optional. Link anchor format. Default \u0026#39;\u0026amp;laquo; %link\u0026#39;. * @param string $link Optional. Link permalink format. Default \u0026#39;%title\u0026#39;. * @param bool $in_same_term Optional. Whether link should be in the same taxonomy term. * Default false. * @param int[]|string $excluded_terms Optional. Array or comma-separated list of excluded term IDs. * Default empty. * @param string $taxonomy Optional. Taxonomy, if `$in_same_term` is true. Default \u0026#39;category\u0026#39;. */ function previous_post_link( $format = \u0026#39;\u0026amp;laquo; %link\u0026#39;, $link = \u0026#39;%title\u0026#39;, $in_same_term = false, $excluded_terms = \u0026#39;\u0026#39;, $taxonomy = \u0026#39;category\u0026#39; ) 获取下一篇文章链接 1 2 3 4 5 6 7 8 9 10 11 12 /** * @see get_next_post_link() * * @param string $format Optional. Link anchor format. Default \u0026#39;\u0026amp;laquo; %link\u0026#39;. * @param string $link Optional. Link permalink format. Default \u0026#39;%title\u0026#39;. * @param bool $in_same_term Optional. Whether link should be in the same taxonomy term. * Default false. * @param int[]|string $excluded_terms Optional. Array or comma-separated list of excluded term IDs. * Default empty. * @param string $taxonomy Optional. Taxonomy, if `$in_same_term` is true. Default \u0026#39;category\u0026#39;. */ function next_post_link( $format = \u0026#39;%link \u0026amp;raquo;\u0026#39;, $link = \u0026#39;%title\u0026#39;, $in_same_term = false, $excluded_terms = \u0026#39;\u0026#39;, $taxonomy = \u0026#39;category\u0026#39; ) 使用举例 1 2 3 4 5 6 7 8 9 \u0026lt;?php if (have_posts()) :?\u0026gt; \u0026lt;?php while (have_posts()) : the_post(); ?\u0026gt; \u0026lt;?php the_content(); ?\u0026gt; \u0026lt;?php wp_link_pages(); ?\u0026gt; \u0026lt;?php endwhile; ?\u0026gt; \u0026lt;?php endif; ?\u0026gt; \u0026lt;?php previous_post_link(\u0026#39;上⼀篇：%link\u0026#39;); ?\u0026gt; \u0026lt;?php next_post_link(\u0026#39;下⼀篇：%link\u0026#39;); ?\u0026gt; 列表分页 简单分页 1 2 3 4 5 6 7 8 9 10 \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;分别获取上⼀⻚和下⼀⻚的链接\u0026lt;/p\u0026gt; \u0026lt;?php previous_posts_link(); ?\u0026gt; \u0026lt;?php next_posts_link(); ?\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;同时获取上下⻚的链接\u0026lt;/p\u0026gt; \u0026lt;?php posts_nav_link(); ?\u0026gt; \u0026lt;/div\u0026gt; 数字分页 1 2 3 4 5 6 7 \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;推荐的数字分⻚函数执⾏的效果\u0026lt;/p\u0026gt; \u0026lt;?php the_posts_pagination(); ?\u0026gt; \u0026lt;/div\u0026gt; //wp 4.1之前的方式 \u0026lt;?php echo paginate_links(); ?\u0026gt; 开启自动生成页面标题功能 1 2 3 4 5 add_action(\u0026#39;after_setup_theme\u0026#39;, function () { add_theme_support(\u0026#39;title-tag\u0026#39;); }); //通过wp_head();触发显示 导航菜单功能 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //1.主题的functions.php中注册菜单 add_action(\u0026#39;after_setup_theme\u0026#39;, function () { //注册导航菜单，用于关联后台设置的菜单，这里nav-1相当于一个标识符，和前台wp_nav_menu的theme_location对应 register_nav_menus([ \u0026#39;nav-1\u0026#39; =\u0026gt; \u0026#39;顶部导航\u0026#39; ]); }) //2.前台显示菜单 \u0026lt;?php wp_nav_menu([ \u0026#39;theme_location\u0026#39; =\u0026gt; \u0026#39;nav-1\u0026#39; ]); ?\u0026gt; wp_nav_menu详细参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $defaults = array( \u0026#39;theme_location\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //调⽤菜单的名称，名称是你⾃⼰注册菜单的时候⾃定义的 \u0026#39;menu\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //使⽤导航菜单的名称调⽤菜单，可以是 ID、别名和名字（按顺序匹配） \u0026#39;container\u0026#39; =\u0026gt; \u0026#39;div\u0026#39;, //最外层容器的标签，只⽀持 div 和 nav 标签 \u0026#39;container_class\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //外层容器的class \u0026#39;container_id\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //外层容器的 ID \u0026#39;menu_class\u0026#39; =\u0026gt; \u0026#39;menu\u0026#39;, //ul ⽗节点的 class 属性 \u0026#39;menu_id\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //ul ⽗节点的 id 属性 \u0026#39;echo\u0026#39; =\u0026gt; true, //布尔值，是否输出菜单，为false是可以⽤于赋值 \u0026#39;fallback_cb\u0026#39; =\u0026gt; \u0026#39;wp_page_menu\u0026#39;, //当前设置的菜单不存在时，显⽰此处设置的菜单 \u0026#39;before\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //显⽰在每个菜单链接前的⽂本 \u0026#39;after\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //显⽰在每个菜单链接后的⽂本 \u0026#39;link_before\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //显⽰在每个菜单链接⽂本前的⽂本 \u0026#39;link_after\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, //显⽰在每个菜单链接⽂本后的⽂本 \u0026#39;items_wrap\u0026#39; =\u0026gt; \u0026#39;\u0026lt;ul class=\u0026#34;%1$s\u0026#34; id=\u0026#34;%2$s\u0026#34;\u0026gt;%3$s \u0026lt;/ul\u0026gt;\u0026#39;, //菜单的输出结构， \u0026#39;depth\u0026#39; =\u0026gt; 0, //显⽰菜单深度，0为显⽰所有 \u0026#39;walker\u0026#39; =\u0026gt; \u0026#39;\u0026#39; //菜单的结构对象 通过改参数可以制作任意结构的导航菜单 ); wp_nav_menu( $defaults); 边栏工具功能 开启边栏工具 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 add_action(\u0026#39;widgets_init\u0026#39;, function () { register_sidebar([ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;边栏1\u0026#39;, //⼩⼯具的区域名称，默认是 \u0026#39;sidebar\u0026#39; 加 数字 ID,如：sidebar-1 \u0026#39;id\u0026#39;=\u0026gt; \u0026#39;footer_area_one\u0026#39;, //区域的ID，默认是⼀个⾃动递增的数字 ID \u0026#39;description\u0026#39;=\u0026gt; \u0026#39;第1个边栏\u0026#39;, //区域的描述，默认为空 \u0026#39;before_widget\u0026#39; =\u0026gt; \u0026#39;\u0026lt;section id=\u0026#34;%1$s\u0026#34; class=\u0026#34;%2$s widget\u0026#34;\u0026gt;\u0026#39;, //区域的内容前的HTML代码，默认： \u0026#39;\u0026#39;） \u0026#39;after_widget\u0026#39;=\u0026gt; \u0026#39;\u0026#39;, //区域内容后的HTML代码，默认： \u0026#34;\\n\u0026#34; \u0026#39;before_title\u0026#39;=\u0026gt; \u0026#39;\u0026#39;, //区域标题前的HTML代码，默认： \u0026#39;after_title\u0026#39;=\u0026gt; \u0026#39;\u0026#39;, //区域标题后的HTML代码，默认：\u0026#34;\\n\u0026#34; ]); }); 前台显示指定边栏 1 2 3 \u0026lt;ul class=\u0026#34;sidebar\u0026#34;\u0026gt; \u0026lt;?php dynamic_sidebar(\u0026#39;sidebar-1\u0026#39;); //通过id获取指定边栏信息 ?\u0026gt; \u0026lt;/ul\u0026gt; 判断边栏内是否包含小工具 is_active_sidebar() 1 2 3 4 5 \u0026lt;?php if(is_active_sidebar(\u0026#39;left-sidebar\u0026#39;)):?\u0026gt; \u0026lt;ul class=\u0026#34;sidebar\u0026#34;\u0026gt; \u0026lt;?php dynamic_sidebar(\u0026#39;left-sidebar\u0026#39;); ?\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;?php endif;?\u0026gt; 特色图像功能 开启特色图像 1 2 3 add_action(\u0026#39;after_setup_theme\u0026#39;, function () { add_theme_support(\u0026#39;post-thumbnails\u0026#39;); }); 获取特色图像 1 2 3 4 5 6 7 8 9 10 11 /** * @see get_the_post_thumbnail() * * @param string|int[] $size Default \u0026#39;post-thumbnail\u0026#39;. * 系统内置的$size有 thumbnail：缩略图; meduim：中图; large：大图; full：原图 * 如果$size的尺寸找不到，则显示full原图. * @param string|array $attr Optional. Query string or array of attributes. Default empty. */ function the_post_thumbnail( $size = \u0026#39;post-thumbnail\u0026#39;, $attr = \u0026#39;\u0026#39; ) { echo get_the_post_thumbnail( null, $size, $attr ); } 定义更多图像尺寸 1 2 3 4 5 6 7 8 9 add_action(\u0026#39;after_setup_theme\u0026#39;, function () { add_theme_support(\u0026#39;post-thumbnails\u0026#39;); //post-thumbnail尺寸默认是不存在的，可以通过代码设置 set_post_thumbnail_size(100, 100, true); //新增自定义尺寸 add_image_size(\u0026#39;category-thumbnail\u0026#39;, 50, 50); }); 常用函数 1 2 3 4 5 6 7 8 9 10 11 //获取图片说明信息 the_post_thumbnail_caption(); //判断文章是否包含特色图片 has_post_thumbnail(); //获取特色图像id get_the_post_thumbnail_id(); //获取特色图像链接 get_the_post_thumbnail_url(); 自定义栏目功能 后台设置 获取自定义栏目信息 1 2 3 4 5 6 7 8 9 10 11 /** * @param int $post_id Post ID. * @param string $key Optional. The meta key to retrieve. By default, * returns data for all keys. Default empty. * @param bool $single Optional. Whether to return a single value. * This parameter has no effect if `$key` is not specified. * Default false. */ function get_post_meta( $post_id, $key = \u0026#39;\u0026#39;, $single = false ) { return get_metadata( \u0026#39;post\u0026#39;, $post_id, $key, $single ); } 使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php if( have_posts() ): ?\u0026gt; \u0026lt;?php while( have_posts() ): the_post(); ?\u0026gt; \u0026lt;div\u0026gt; \u0026lt;strong\u0026gt;⽂章相册信息（⾃定义的）：get_post_meta\u0026lt;/strong\u0026gt; \u0026lt;?php print_r( get_post_meta( get_the_ID(), \u0026#39;gallary_img\u0026#39;, false ) ); ?\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;strong\u0026gt;⽂章价格信息（⾃定义的）：get_post_meta\u0026lt;/strong\u0026gt; \u0026lt;strong\u0026gt;因为价格信息就1个值，通过第3个个参数可以直接获取到值\u0026lt;/strong\u0026gt; \u0026lt;?php print_r( get_post_meta( get_the_ID(), \u0026#39;price\u0026#39;, true ) ); ?\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;strong\u0026gt;⽂章价格信息（⾃定义的）：get_post_meta\u0026lt;/strong\u0026gt; \u0026lt;?php print_r( get_post_meta( get_the_ID(), \u0026#39;price\u0026#39; ) ); ?\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;?php endwhile; ?\u0026gt; \u0026lt;?php endif; ?\u0026gt; 通过代码设置 添加add_post_meta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * @param int $post_id Post ID. * @param string $meta_key Metadata name. * @param mixed $meta_value Metadata value. Must be serializable if non-scalar. * @param bool $unique Optional. Whether the same key should not be added. * Default false. * @return int|false Meta ID on success, false on failure. */ function add_post_meta( $post_id, $meta_key, $meta_value, $unique = false ) { // Make sure meta is added to the post, not a revision. $the_post = wp_is_post_revision( $post_id ); if ( $the_post ) { $post_id = $the_post; } return add_metadata( \u0026#39;post\u0026#39;, $post_id, $meta_key, $meta_value, $unique ); } 更新update_post_meta，不存在则新增 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * @param int $post_id Post ID. * @param string $meta_key Metadata key. * @param mixed $meta_value Metadata value. Must be serializable if non-scalar. * @param mixed $prev_value Optional. Previous value to check before updating. * If specified, only update existing metadata entries with * this value. Otherwise, update all entries. Default empty. * @return int|bool Meta ID if the key didn\u0026#39;t exist, true on successful update, * false on failure or if the value passed to the function * is the same as the one that is already in the database. */ function update_post_meta( $post_id, $meta_key, $meta_value, $prev_value = \u0026#39;\u0026#39; ) { // Make sure meta is updated for the post, not for a revision. $the_post = wp_is_post_revision( $post_id ); if ( $the_post ) { $post_id = $the_post; } return update_metadata( \u0026#39;post\u0026#39;, $post_id, $meta_key, $meta_value, $prev_value ); } 删除delete_post_meta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * @param int $post_id Post ID. * @param string $meta_key Metadata name. * @param mixed $meta_value Optional. Metadata value. If provided, * rows will only be removed that match the value. * Must be serializable if non-scalar. Default empty. * @return bool True on success, false on failure. */ function delete_post_meta( $post_id, $meta_key, $meta_value = \u0026#39;\u0026#39; ) { // Make sure meta is deleted from the post, not from a revision. $the_post = wp_is_post_revision( $post_id ); if ( $the_post ) { $post_id = $the_post; } return delete_metadata( \u0026#39;post\u0026#39;, $post_id, $meta_key, $meta_value ); } 隐藏的自定义栏目，后台无法设置 1 2 3 //下滑线开头的字段，后台不展示，用户无法设置 add_post_meta($post_id, \u0026#39;_myKey\u0026#39;, \u0026#39;隐藏的值\u0026#39;); get_post_meta($post_id, \u0026#39;_mykey\u0026#39;, true); 常用功能 设置浏览次数 定义函数 通过 隐藏的(下划线开头的key)自定义栏目实现浏览次数。functions.php中定义以下函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * 设置⽂章/⻚⾯ 浏览次数 * _wphollis_postviews是⾃定义栏⽬的名字 * @param int $post_id ⽂章的ID编号 */ function wphollis_set_postviews($post_id) { // 详情⻚才处理 if ( is_singular() \u0026amp;\u0026amp; ! empty( $post_id ) ) { $views = get_post_meta($post_id, \u0026#39;_wphollis_postviews\u0026#39;, true); $views = ! empty( $views ) ? $views : 0; $views++; update_post_meta($post_id, \u0026#39;_wphollis_postviews\u0026#39;, $views); } } /** * 获取⽂章/⻚⾯ 浏览次数 * @param int ⽂章的ID编号 * @return int 浏览次数 */ function wphollis_get_postviews( $post_id ) { if ( ! empty( $post_id ) ) { $views = get_post_meta($post_id, \u0026#39;_wphollis_postviews\u0026#39;, true); $views = ! empty( $views ) ? (int)$views : 0; return $views; } } 前台使用 （在内容详情页中添加以下代码） 1 2 3 4 5 6 7 8 \u0026lt;?php wphollis_set_postviews(get_queried_object_id());//更新文章浏览次数 ?\u0026gt; \u0026lt;?php if (have_posts()) :?\u0026gt; \u0026lt;?php while (have_posts()) : the_post(); ?\u0026gt; \u0026lt;?php the_title(); ?\u0026gt; \u0026lt;?php wphollis_get_postviews(get_the_ID());//获取文章浏览次数 ?\u0026gt; \u0026lt;?php endwhile; ?\u0026gt; \u0026lt;?php endif; ?\u0026gt; 获取当前用户访问的网页网址 在当前主题functions.php文件中定义以下函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 获取⽤⼾当前访问的⽹址 */ function wphollis_get_current_url() { global $wp, $wp_rewrite; // 获取重写规则，朴素模式规则为空 $rewrite = $wp_rewrite-\u0026gt;wp_rewrite_rules(); // ⾮朴素模式下，返回当前⽹址 if ( !empty($rewrite) ) { return home_url( $wp-\u0026gt;request ); } // 在朴素模式下，返回当前⽹址 return home_url( \u0026#39;?\u0026#39; . $wp-\u0026gt;query_string ); } 正文自动截取 在当前主题functions.php文件中定义以下函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * @params $len 要截取的字符长度 * @params $suffix 后缀标记 * */ function hollis_strim_post_content($len = 100, $suffix = \u0026#39;...\u0026#39;) { //获取正文信息，并做必要处理 $content = get_the_content(); //这里触发the_content的钩子，执行挂载该钩子的所有方法 //这里不写这个语句也可以，但是为了兼容wp的扩展性要求加上 $content = apply_filters(\u0026#39;the_content\u0026#39;, $content); $content = str_replace(\u0026#39;]]\u0026gt;\u0026#39;, \u0026#39;]]\u0026amp;gt;\u0026#39;, $content); //去除正文中的HTML标签 $content = strip_tags($content); if (mb_strlen($content) \u0026lt;= $len) { //字符数量少于要截取的长度，则展示全部 return $content; } else { return $content = mb_substr($content, 0, $len) . $suffix; } } 给嵌套评论添加回复关系信息 原理就是通过get_comment_author_link钩子，把评论者的link扩展成带回复关系的两个link\n在当前主题functions.php文件中定义以下函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * 增加谁回复谁 * 所有⽤到的钩⼦信息⸺ * apply_filters( \u0026#39;get_comment_author_link\u0026#39;, $return, $author, $comment-\u0026gt;comment_ID ); * @param string $out 未修改的评论数据，即wordpress默认提供的数据 * @param int $comment_id 评论的编号 * @return string */ function wphollis_who_resp_who($out, $author, $comment_id) { $comment = get_comment($comment_id); // 如果没有⽗级评论，则正常返回，因为没有回复关系 if ( empty($comment-\u0026gt;comment_parent) ) { return $out; } /** * 如果有⽗级评论，则添加回复关系 */ // 获取⽗（原）评论 $parent = get_comment($comment-\u0026gt;comment_parent); // 获取⽗（原）评论作者 $pauthor = get_comment_author($parent); // 构件回复关系 $pcid = \u0026#39;#comment-\u0026#39; . $parent-\u0026gt;comment_ID; $new = $out . \u0026#39; 回复 \u0026#39;. \u0026#34;\u0026lt;a href=\u0026#39;{$pcid}\u0026#39;\u0026gt;{$pauthor}\u0026lt;/a\u0026gt;\u0026#34;; // 返回修改后的评论数据 return $new; } add_filter(\u0026#39;get_comment_author_link\u0026#39;, \u0026#39;wphollis_who_resp_who\u0026#39;, 10, 3); 解决评论模板notice提示 调用comments_template()方法的时候，wp会优先查找当前主题下有没有comments.php文件，如果没有则采用wp自带的模板wp-includes/theme-compat/comments.php\n修改菜单输出结构 添加并定义⼀个⾃定义函数⽂件（名称随意）：class-my-nav-walker.php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class wphollis_Nav_Walker extends Walker_Nav_Menu { /** * 修改⼆级菜单 */ public function end_lvl( \u0026amp;$output, $depth = 0, $args = array() ) { if ( isset( $args-\u0026gt;item_spacing ) \u0026amp;\u0026amp; \u0026#39;discard\u0026#39; === $args-\u0026gt;item_spacing ) { $t = \u0026#39;\u0026#39;; $n = \u0026#39;\u0026#39;; } else { $t = \u0026#34;\\t\u0026#34;; $n = \u0026#34;\\n\u0026#34;; } $indent = str_repeat( $t, $depth ); $suffix = \u0026#39;\u0026lt;span class=\u0026#34;fa fa-angle-down\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026#39;; // 添加的按钮对应的HTML $output .= \u0026#34;$indent\u0026lt;/ul\u0026gt;{$suffix}{$n}\u0026#34;; } } 在funcitons.php中加载这个类 1 2 3 add_action(\u0026#39;after_setup_theme\u0026#39;, function () { include get_theme_file_path() . \u0026#39;/inc/class-my-nav-walker.php\u0026#39;; }); 前台页面中调用菜单 1 2 3 4 5 6 7 \u0026lt;?php wp_nav_menu([ \u0026#39;theme_location\u0026#39; =\u0026gt; \u0026#39;nav-1\u0026#39;, \u0026#39;walker\u0026#39; =\u0026gt; new wphollis_Nav_Walker() ]); ?\u0026gt; 实战案例 导入测试数据 下载好 xml的数据⽂件, 在 后台 ⼯具 \u0026mdash;-\u0026gt; 导⼊ \u0026mdash;-\u0026gt; WordPress导⼊器安装 \u0026mdash;-\u0026gt; 选择xml⽂件导⼊数\n据\n开启所需功能并引入所需的样式文件 functions.php文件中定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 add_action(\u0026#39;after_setup_theme\u0026#39;, function () { // 开启⻚⾯标题功能 add_theme_support(\u0026#39;title-tag\u0026#39;); // 开启特色图像 add_theme_support(\u0026#39;post-thumbnails\u0026#39;); // 定义导航菜单 register_nav_menus([ \u0026#39;header_menu\u0026#39; =\u0026gt; \u0026#39;顶部导航\u0026#39;, \u0026#39;footer_menu\u0026#39; =\u0026gt; \u0026#39;底部导航\u0026#39;, ]); }); // 定义边栏 add_action(\u0026#39;widgets_init\u0026#39;, function () { register_sidebar([ \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;边栏1\u0026#39;, \u0026#39;id\u0026#39; =\u0026gt; \u0026#39;sidebar1\u0026#39;, \u0026#39;decsription\u0026#39; =\u0026gt; \u0026#39;边栏1\u0026#39;, ]); }); // 引入所需的样式文件 add_action(\u0026#39;wp_enqueue_scripts\u0026#39;, function () { wp_enqueue_style(\u0026#39;main-css\u0026#39;, get_theme_file_uri() . \u0026#39;/main.css\u0026#39;, [], \u0026#39;1.0\u0026#39;); wp_enqueue_script(\u0026#39;main-js\u0026#39;, get_theme_file_uri() . \u0026#39;/main.js\u0026#39;, [], \u0026#39;1.0\u0026#39;); }); 获取登录和注册的URL 注册地址 1 wp_registration_url(); 登录地址 1 wp_login_url(wphollis_get_current_url()); 获取文章作者 1 2 3 4 5 6 7 8 9 10 11 // 获取文章作者归档页。 作者名称+链接 get_the_author_posts_link(); // 获取文章作者归档页url get_author_posts_url(); // 获取作者id get_the_author_meta(\u0026#39;ID\u0026#39;); // 获取用户头像。get_avatar($id_or_email, $size); get_avatar(get_the_author_meta(\u0026#39;ID\u0026#39;), 24); 回复评论，不刷新定位到回复框 在functions.php中添加：\n1 2 3 4 5 //（是否是详情页 \u0026amp;\u0026amp; ⽂章是否开启评论 \u0026amp;\u0026amp; 后台是否开启嵌套评论） // 调取官⽅原⽣回复评论跳转函数 if(is_singular() \u0026amp;\u0026amp; comments_open() \u0026amp;\u0026amp; get_option(\u0026#39;thread_comments\u0026#39;)){ wp_enqueue_script(\u0026#39;comment-reply\u0026#39;); } 设置wp指定的class属性值 在body ⾥⾯设置class属性值 1 \u0026lt;body \u0026lt;?php body_class() ?\u0026gt; \u0026gt; 在article ⾥⾯设置class属性值 1 \u0026lt;article \u0026lt;?php post_class() ?\u0026gt; \u0026gt; 归档页标题调取以及获取文章的缩略图 1 2 3 4 5 6 \u0026lt;!-- 归档页标题 --\u0026gt; \u0026lt;header class=\u0026#34;list-header\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;span\u0026gt;\u0026lt;?php the_archivce_title(); ?\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;/header\u0026gt; 1 2 3 4 5 6 7 8 \u0026lt;!-- 获取文章缩略图 --\u0026gt; \u0026lt;a href=\u0026#34;\u0026lt;?php the_permalink() ?\u0026gt;\u0026#34;\u0026gt; \u0026lt;?php if (has_post_thumbnail()) : ?\u0026gt; \u0026lt;?php the_post_thumbnail(\u0026#39;thumbnail\u0026#39;); ?\u0026gt; \u0026lt;?php else : ?\u0026gt; \u0026lt;img src=\u0026#34;\u0026lt;?php echo get_theme_file_uri(); ?\u0026gt;/default.png\u0026#34;\u0026gt; \u0026lt;?php endif; ?\u0026gt; \u0026lt;/a\u0026gt; 首页模板文件开发 1 2 3 4 5 6 7 8 9 \u0026lt;!-- 判断置顶⽂章显⽰ is_sticky()--\u0026gt; \u0026lt;?php if(is_sticky()) :?\u0026gt; \u0026lt;span class=\u0026#34;sticky\u0026#34;\u0026gt;置顶\u0026lt;/span\u0026gt; \u0026lt;?php endif; ?\u0026gt; \u0026lt;!--调取分⻚--\u0026gt; \u0026lt;div class=\u0026#34;posts-nav\u0026#34;\u0026gt; \u0026lt;?php echo the_posts_pagination(); ?\u0026gt; \u0026lt;/div\u0026gt; ","date":"2024-03-23T02:17:45+08:00","permalink":"https://hollisho.github.io/p/wordpress%E4%B8%BB%E9%A2%98%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/","title":"Wordpress主题核心知识点梳理"}]